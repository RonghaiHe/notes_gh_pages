<!DOCTYPE html><html class=no-js lang=zh> <head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=awslasasd的笔记本 name=description><meta content=awslasasd name=author><link href=https://awslasasd.github.io/Class/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ rel=canonical><link href=../%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/ rel=prev><link href=../%E6%99%BA%E8%83%BD%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/ rel=next><link href=../../assets/images/favicon.png rel=icon><meta content="mkdocs-1.6.0, mkdocs-material-9.5.28" name=generator><title>人工智能与机器学习 - awslasasd's Notebook</title><link href=../../assets/stylesheets/main.6543a935.min.css rel=stylesheet><link href=../../assets/stylesheets/palette.06af60db.min.css rel=stylesheet><style>:root{--md-admonition-icon--note:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M1 7.775V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 0 1 0 2.474l-5.026 5.026a1.75 1.75 0 0 1-2.474 0l-6.25-6.25A1.752 1.752 0 0 1 1 7.775Zm1.5 0c0 .066.026.13.073.177l6.25 6.25a.25.25 0 0 0 .354 0l5.025-5.025a.25.25 0 0 0 0-.354l-6.25-6.25a.25.25 0 0 0-.177-.073H2.75a.25.25 0 0 0-.25.25ZM6 5a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z"/></svg>');--md-admonition-icon--abstract:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M2.5 1.75v11.5c0 .138.112.25.25.25h3.17a.75.75 0 0 1 0 1.5H2.75A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8.5C12.216 0 13 .784 13 1.75v7.736a.75.75 0 0 1-1.5 0V1.75a.25.25 0 0 0-.25-.25h-8.5a.25.25 0 0 0-.25.25Zm13.274 9.537v-.001l-4.557 4.45a.75.75 0 0 1-1.055-.008l-1.943-1.95a.75.75 0 0 1 1.062-1.058l1.419 1.425 4.026-3.932a.75.75 0 1 1 1.048 1.074ZM4.75 4h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM4 7.75A.75.75 0 0 1 4.75 7h2a.75.75 0 0 1 0 1.5h-2A.75.75 0 0 1 4 7.75Z"/></svg>');--md-admonition-icon--info:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>');--md-admonition-icon--tip:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M3.499.75a.75.75 0 0 1 1.5 0v.996C5.9 2.903 6.793 3.65 7.662 4.376l.24.202c-.036-.694.055-1.422.426-2.163C9.1.873 10.794-.045 12.622.26 14.408.558 16 1.94 16 4.25c0 1.278-.954 2.575-2.44 2.734l.146.508.065.22c.203.701.412 1.455.476 2.226.142 1.707-.4 3.03-1.487 3.898C11.714 14.671 10.27 15 8.75 15h-6a.75.75 0 0 1 0-1.5h1.376a4.484 4.484 0 0 1-.563-1.191 3.835 3.835 0 0 1-.05-2.063 4.647 4.647 0 0 1-2.025-.293.75.75 0 0 1 .525-1.406c1.357.507 2.376-.006 2.698-.318l.009-.01a.747.747 0 0 1 1.06 0 .748.748 0 0 1-.012 1.074c-.912.92-.992 1.835-.768 2.586.221.74.745 1.337 1.196 1.621H8.75c1.343 0 2.398-.296 3.074-.836.635-.507 1.036-1.31.928-2.602-.05-.603-.216-1.224-.422-1.93l-.064-.221c-.12-.407-.246-.84-.353-1.29a2.425 2.425 0 0 1-.507-.441 3.075 3.075 0 0 1-.633-1.248.75.75 0 0 1 1.455-.364c.046.185.144.436.31.627.146.168.353.305.712.305.738 0 1.25-.615 1.25-1.25 0-1.47-.95-2.315-2.123-2.51-1.172-.196-2.227.387-2.706 1.345-.46.92-.27 1.774.019 3.062l.042.19a.884.884 0 0 1 .01.05c.348.443.666.949.94 1.553a.75.75 0 1 1-1.365.62c-.553-1.217-1.32-1.94-2.3-2.768L6.7 5.527c-.814-.68-1.75-1.462-2.692-2.619a3.737 3.737 0 0 0-1.023.88c-.406.495-.663 1.036-.722 1.508.116.122.306.21.591.239.388.038.797-.06 1.032-.19a.75.75 0 0 1 .728 1.31c-.515.287-1.23.439-1.906.373-.682-.067-1.473-.38-1.879-1.193L.75 5.677V5.5c0-.984.48-1.94 1.077-2.664.46-.559 1.05-1.055 1.673-1.353V.75Z"/></svg>');--md-admonition-icon--success:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"/></svg>');--md-admonition-icon--question:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.92 6.085h.001a.749.749 0 1 1-1.342-.67c.169-.339.436-.701.849-.977C6.845 4.16 7.369 4 8 4a2.756 2.756 0 0 1 1.637.525c.503.377.863.965.863 1.725 0 .448-.115.83-.329 1.15-.205.307-.47.513-.692.662-.109.072-.22.138-.313.195l-.006.004a6.24 6.24 0 0 0-.26.16.952.952 0 0 0-.276.245.75.75 0 0 1-1.248-.832c.184-.264.42-.489.692-.661.103-.067.207-.132.313-.195l.007-.004c.1-.061.182-.11.258-.161a.969.969 0 0 0 .277-.245C8.96 6.514 9 6.427 9 6.25a.612.612 0 0 0-.262-.525A1.27 1.27 0 0 0 8 5.5c-.369 0-.595.09-.74.187a1.01 1.01 0 0 0-.34.398ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>');--md-admonition-icon--warning:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>');--md-admonition-icon--failure:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M2.344 2.343h-.001a8 8 0 0 1 11.314 11.314A8.002 8.002 0 0 1 .234 10.089a8 8 0 0 1 2.11-7.746Zm1.06 10.253a6.5 6.5 0 1 0 9.108-9.275 6.5 6.5 0 0 0-9.108 9.275ZM6.03 4.97 8 6.94l1.97-1.97a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L9.06 8l1.97 1.97a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L8 9.06l-1.97 1.97a.749.749 0 0 1-1.275-.326.749.749 0 0 1 .215-.734L6.94 8 4.97 6.03a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018Z"/></svg>');--md-admonition-icon--danger:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M9.504.43a1.516 1.516 0 0 1 2.437 1.713L10.415 5.5h2.123c1.57 0 2.346 1.909 1.22 3.004l-7.34 7.142a1.249 1.249 0 0 1-.871.354h-.302a1.25 1.25 0 0 1-1.157-1.723L5.633 10.5H3.462c-1.57 0-2.346-1.909-1.22-3.004L9.503.429Zm1.047 1.074L3.286 8.571A.25.25 0 0 0 3.462 9H6.75a.75.75 0 0 1 .694 1.034l-1.713 4.188 6.982-6.793A.25.25 0 0 0 12.538 7H9.25a.75.75 0 0 1-.683-1.06l2.008-4.418.003-.006a.036.036 0 0 0-.004-.009l-.006-.006-.008-.001c-.003 0-.006.002-.009.004Z"/></svg>');--md-admonition-icon--bug:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M4.72.22a.75.75 0 0 1 1.06 0l1 .999a3.488 3.488 0 0 1 2.441 0l.999-1a.748.748 0 0 1 1.265.332.75.75 0 0 1-.205.729l-.775.776c.616.63.995 1.493.995 2.444v.327c0 .1-.009.197-.025.292.408.14.764.392 1.029.722l1.968-.787a.75.75 0 0 1 .556 1.392L13 7.258V9h2.25a.75.75 0 0 1 0 1.5H13v.5c0 .409-.049.806-.141 1.186l2.17.868a.75.75 0 0 1-.557 1.392l-2.184-.873A4.997 4.997 0 0 1 8 16a4.997 4.997 0 0 1-4.288-2.427l-2.183.873a.75.75 0 0 1-.558-1.392l2.17-.868A5.036 5.036 0 0 1 3 11v-.5H.75a.75.75 0 0 1 0-1.5H3V7.258L.971 6.446a.75.75 0 0 1 .558-1.392l1.967.787c.265-.33.62-.583 1.03-.722a1.677 1.677 0 0 1-.026-.292V4.5c0-.951.38-1.814.995-2.444L4.72 1.28a.75.75 0 0 1 0-1.06Zm.53 6.28a.75.75 0 0 0-.75.75V11a3.5 3.5 0 1 0 7 0V7.25a.75.75 0 0 0-.75-.75ZM6.173 5h3.654A.172.172 0 0 0 10 4.827V4.5a2 2 0 1 0-4 0v.327c0 .096.077.173.173.173Z"/></svg>');--md-admonition-icon--example:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"/></svg>');--md-admonition-icon--quote:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M1.75 2.5h10.5a.75.75 0 0 1 0 1.5H1.75a.75.75 0 0 1 0-1.5Zm4 5h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1 0-1.5Zm0 5h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1 0-1.5ZM2.5 7.75v6a.75.75 0 0 1-1.5 0v-6a.75.75 0 0 1 1.5 0Z"/></svg>');}</style><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&display=fallback" rel=stylesheet><style>:root{--md-text-font:"Noto Serif SC";--md-code-font:"JetBrains Mono"}</style><link href=../../css/heti.css rel=stylesheet><link href=../../style/css/custom.css rel=stylesheet><link href=../../style/css/counter.css rel=stylesheet><link href=../../style/css/toc.css rel=stylesheet><link href=../../style/css/flink.css rel=stylesheet><link href=https://cdn.tonycrane.cc/jbmono/jetbrainsmono.css rel=stylesheet><link href=https://cdn.tonycrane.cc/lxgw/lxgwscreen.css rel=stylesheet><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body data-md-color-accent=red data-md-color-primary=white data-md-color-scheme=default dir=ltr> <input autocomplete=off class=md-toggle data-md-toggle=drawer id=__drawer type=checkbox> <input autocomplete=off class=md-toggle data-md-toggle=search id=__search type=checkbox> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a class=md-skip href=#_1> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav aria-label=页眉 class="md-header__inner md-grid"> <a aria-label="awslasasd's Notebook" class="md-header__button md-logo" data-md-component=logo href=../.. title="awslasasd's Notebook"> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"></path></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> awslasasd's Notebook </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 人工智能与机器学习 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input aria-label="Switch to dark mode" class=md-option data-md-color-accent=red data-md-color-media="(prefers-color-scheme: light)" data-md-color-primary=white data-md-color-scheme=default id=__palette_0 name=__palette type=radio> <label class="md-header__button md-icon" for=__palette_1 hidden title="Switch to dark mode"> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"></path></svg> </label> <input aria-label="Switch to light mode" class=md-option data-md-color-accent=indigo data-md-color-media="(prefers-color-scheme: dark)" data-md-color-primary=indigo data-md-color-scheme=slate id=__palette_1 name=__palette type=radio> <label class="md-header__button md-icon" for=__palette_0 hidden title="Switch to light mode"> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"></path></svg> </label> </form> <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input aria-label=搜索 autocapitalize=off autocomplete=off autocorrect=off class=md-search__input data-md-component=search-query name=query placeholder=搜索 required spellcheck=false type=text> <label class="md-search__icon md-icon" for=__search> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg> </label> <nav aria-label=查找 class=md-search__options> <a aria-label=分享 class="md-search__icon md-icon" data-clipboard data-clipboard-text data-md-component=search-share href=javascript:void(0) tabindex=-1 title=分享> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"></path></svg> </a> <button aria-label=清空当前内容 class="md-search__icon md-icon" tabindex=-1 title=清空当前内容 type=reset> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"></path></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix tabindex=0> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a class=md-source data-md-component=source href=https://github.com/awslasasd/awslasasd.github.io title=前往仓库> <div class="md-source__icon md-icon"> <svg viewbox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><!-- Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg> </div> <div class=md-source__repository> awslasasd/Notes </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav aria-label=标签 class=md-tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a class=md-tabs__link href=../..> Home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../%E7%94%B5%E6%B0%94%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/ class=md-tabs__link> Class </a> </li> <li class=md-tabs__item> <a href=../../Robotics/%E7%A9%BA%E4%B8%AD%E6%9C%BA%E5%99%A8%E4%BA%BA/ class=md-tabs__link> Robotics </a> </li> <li class=md-tabs__item> <a href=../../Tools/Git/ class=md-tabs__link> Tools </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav aria-label=导航栏 class="md-nav md-nav--primary md-nav--lifted" data-md-level=0> <label class=md-nav__title for=__drawer> <a aria-label="awslasasd's Notebook" class="md-nav__button md-logo" data-md-component=logo href=../.. title="awslasasd's Notebook"> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"></path></svg> </a> awslasasd's Notebook </label> <div class=md-nav__source> <a class=md-source data-md-component=source href=https://github.com/awslasasd/awslasasd.github.io title=前往仓库> <div class="md-source__icon md-icon"> <svg viewbox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><!-- Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg> </div> <div class=md-source__repository> awslasasd/Notes </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a class=md-nav__link href=../..> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input checked class="md-nav__toggle md-toggle" id=__nav_2 type=checkbox> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> Class </span> <span class="md-nav__icon md-icon"></span> </label> <nav aria-expanded=true aria-labelledby=__nav_2_label class=md-nav data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Class </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../%E7%94%B5%E6%B0%94%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/ class=md-nav__link> <span class=md-ellipsis> 电气控制技术 </span> </a> </li> <li class=md-nav__item> <a href=../%E6%99%BA%E8%83%BD%E7%94%B5%E5%AD%90%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91/ class=md-nav__link> <span class=md-ellipsis> 智能电子设备开发 </span> </a> </li> <li class=md-nav__item> <a href=../%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 现代控制原理 </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" id=__toc type=checkbox> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 人工智能与机器学习 </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 人工智能与机器学习 </span> </a> <nav aria-label=目录 class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a class=md-nav__link href=#_2> <span class=md-ellipsis> 人工智能 </span> </a> <nav aria-label=人工智能 class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a class=md-nav__link href=#_3> <span class=md-ellipsis> 绪论 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#agent> <span class=md-ellipsis> 智能AGENT </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_15> <span class=md-ellipsis> 通过搜索进行问题求解 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_28> <span class=md-ellipsis> 对抗搜索（博弈） </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_32> <span class=md-ellipsis> 逻辑智能体 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_37> <span class=md-ellipsis> 一阶逻辑 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a class=md-nav__link href=#_46> <span class=md-ellipsis> 机器学习 </span> </a> <nav aria-label=机器学习 class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a class=md-nav__link href=#_47> <span class=md-ellipsis> 绪论 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_48> <span class=md-ellipsis> 概念学习 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a class=md-nav__link href=#mo> <span class=md-ellipsis> mo平台作业 </span> </a> <nav aria-label=mo平台作业 class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a class=md-nav__link href=#lab1> <span class=md-ellipsis> LAB1——双相障碍检测 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#lab2> <span class=md-ellipsis> LAB2——机器人自动走迷宫 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#lab3> <span class=md-ellipsis> LAB3——口罩检测 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#lab4> <span class=md-ellipsis> LAB4——作家风格识别 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../%E6%99%BA%E8%83%BD%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/ class=md-nav__link> <span class=md-ellipsis> 智能控制技术 </span> </a> </li> <li class=md-nav__item> <a href=../%E4%BC%A0%E6%84%9F%E4%B8%8E%E6%A3%80%E6%B5%8B/ class=md-nav__link> <span class=md-ellipsis> 传感与检测 </span> </a> </li> <li class=md-nav__item> <a href=../%E6%AF%9B%E6%A6%82/ class=md-nav__link> <span class=md-ellipsis> 毛概 </span> </a> </li> <li class=md-nav__item> <a href=../%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6/ class=md-nav__link> <span class=md-ellipsis> 运动控制 </span> </a> </li> <li class=md-nav__item> <a href=../%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/ class=md-nav__link> <span class=md-ellipsis> 信息安全导论 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" id=__nav_3 type=checkbox> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Robotics </span> <span class="md-nav__icon md-icon"></span> </label> <nav aria-expanded=false aria-labelledby=__nav_3_label class=md-nav data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Robotics </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Robotics/%E7%A9%BA%E4%B8%AD%E6%9C%BA%E5%99%A8%E4%BA%BA/ class=md-nav__link> <span class=md-ellipsis> 空中机器人 </span> </a> </li> <li class=md-nav__item> <a href=../../Robotics/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AB%9E%E8%B5%9B%E5%AE%9E%E8%AE%AD/ class=md-nav__link> <span class=md-ellipsis> 自动化竞赛实训 </span> </a> </li> <li class=md-nav__item> <a href=../../Robotics/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ class=md-nav__link> <span class=md-ellipsis> 机器学习 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" id=__nav_4 type=checkbox> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> Tools </span> <span class="md-nav__icon md-icon"></span> </label> <nav aria-expanded=false aria-labelledby=__nav_4_label class=md-nav data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Tools </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Tools/Git/ class=md-nav__link> <span class=md-ellipsis> Git </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/Createsite/ class=md-nav__link> <span class=md-ellipsis> Createsite </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/latex/ class=md-nav__link> <span class=md-ellipsis> Latex </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/Juypter/ class=md-nav__link> <span class=md-ellipsis> Juypter </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/AI/ class=md-nav__link> <span class=md-ellipsis> AI </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/%E5%8F%91%E5%B1%95%E5%AF%B9%E8%B1%A1%E8%80%83%E8%AF%95/ class=md-nav__link> <span class=md-ellipsis> 发展对象 </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/OneDrive/ class=md-nav__link> <span class=md-ellipsis> OneDrive </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" id=__nav_4_8 type=checkbox> <label class=md-nav__link for=__nav_4_8 id=__nav_4_8_label tabindex=0> <span class=md-ellipsis> Linux </span> <span class="md-nav__icon md-icon"></span> </label> <nav aria-expanded=false aria-labelledby=__nav_4_8_label class=md-nav data-md-level=2> <label class=md-nav__title for=__nav_4_8> <span class="md-nav__icon md-icon"></span> Linux </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Tools/Linux/linux/ class=md-nav__link> <span class=md-ellipsis> 双系统更改开机顺序 </span> </a> </li> <li class=md-nav__item> <a href=../../Tools/Linux/ssh/ class=md-nav__link> <span class=md-ellipsis> SSH </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav aria-label=目录 class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a class=md-nav__link href=#_2> <span class=md-ellipsis> 人工智能 </span> </a> <nav aria-label=人工智能 class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a class=md-nav__link href=#_3> <span class=md-ellipsis> 绪论 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#agent> <span class=md-ellipsis> 智能AGENT </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_15> <span class=md-ellipsis> 通过搜索进行问题求解 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_28> <span class=md-ellipsis> 对抗搜索（博弈） </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_32> <span class=md-ellipsis> 逻辑智能体 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_37> <span class=md-ellipsis> 一阶逻辑 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a class=md-nav__link href=#_46> <span class=md-ellipsis> 机器学习 </span> </a> <nav aria-label=机器学习 class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a class=md-nav__link href=#_47> <span class=md-ellipsis> 绪论 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#_48> <span class=md-ellipsis> 概念学习 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a class=md-nav__link href=#mo> <span class=md-ellipsis> mo平台作业 </span> </a> <nav aria-label=mo平台作业 class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a class=md-nav__link href=#lab1> <span class=md-ellipsis> LAB1——双相障碍检测 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#lab2> <span class=md-ellipsis> LAB2——机器人自动走迷宫 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#lab3> <span class=md-ellipsis> LAB3——口罩检测 </span> </a> </li> <li class=md-nav__item> <a class=md-nav__link href=#lab4> <span class=md-ellipsis> LAB4——作家风格识别 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=_1>人工智能与机器学习<a class=headerlink href=#_1 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h1> <div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;"> <p><span class=twemoji><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8V2m6.78 1a.69.69 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38-2.5-2.5Z"></path></svg></span> 约<span class=heti-skip><span class=heti-spacing> </span>17656<span class=heti-spacing> </span></span>个字 <span class=twemoji><svg viewbox="0 0 640 512" xmlns=http://www.w3.org/2000/svg><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"></path></svg></span> <span>89<span class=heti-spacing> </span></span>行代码 <span class=twemoji><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3L12.5 13Z"></path></svg></span> 预计阅读时间<span class=heti-skip><span class=heti-spacing> </span>70<span class=heti-spacing> </span></span>分钟</p> </div> <details class=note open=open> <summary>课程资源</summary> <div class="tabbed-set tabbed-alternate" data-tabs=1:1><input checked=checked id=__tabbed_1_1 name=__tabbed_1 type=radio><div class=tabbed-labels><label for=__tabbed_1_1>作业资源</label></div> <div class=tabbed-content> <div class=tabbed-block></div> </div> </div> <p>看到是国科大的作业<br> <a href="https://wenku.baidu.com/view/a008b8323a3567ec102de2bd960590c69ec3d8e1.html?_wkts_=1727330708826&needWelcomeRecommand=1">作业</a><br> <a href=https://blog.csdn.net/m0_67495624/article/details/135541806>第二章作业</a><br> <a href=https://www.cc98.org/topic/5795381>小测1</a><br> <a href=https://www.cc98.org/topic/6006987>小测2</a><br></p> <div class="tabbed-set tabbed-alternate" data-tabs=2:2><input checked=checked id=__tabbed_2_1 name=__tabbed_2 type=radio><input id=__tabbed_2_2 name=__tabbed_2 type=radio><div class=tabbed-labels><label for=__tabbed_2_1>分数构成</label><label for=__tabbed_2_2>历年小测</label></div> <div class=tabbed-content> <div class=tabbed-block> <p><span>15%<span class=heti-spacing> </span></span>随堂测试<br> 20% 实验报告<br> 5% 考勤<br> 8% 课后作业<br> 12% 小组大作业<br> 40% 闭卷考试<br></p> </div> <div class=tabbed-block> <p><a href=../class_source/renji/1.pdf>第一次小测</a><br> <a href=../class_source/renji/2.pdf>第二次小测</a><br> <a href=../class_source/renji/3.pdf>第三次小测</a><br> <a href=../class_source/renji/4.pdf>第四次小测</a><br> <a href=../class_source/renji/5.pdf>第五次小测</a><br> <a href=../class_source/renji/6.pdf>第六次小测</a><br></p> </div> </div> </div> </details> <h2 id=_2>人工智能<a class=headerlink href=#_2 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h2> <h3 id=_3>绪论<a class=headerlink href=#_3 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <h4 id=_4>定义<a class=headerlink href=#_4 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p><strong>人工智能概念的一般描述</strong>：Artificial Intelligence，目前是指用<strong>计算机模拟或实现的智能</strong>， 研究如何在机器上实现<strong>人类智能</strong>。即用机器来模仿人的智能。因此人工智能<strong>又称机器智能</strong></p> <p><strong>智能</strong>：辨识区分事物从而做出正确选择的能力（智能<span class=heti-skip><span class=heti-spacing> </span>=<span class=heti-spacing> </span></span>知识<span class=heti-skip><span class=heti-spacing> </span>+<span class=heti-spacing> </span></span>思维）</p> <p><strong>人类的自然智能</strong>：指人在认识客观世界的过程中，由<strong>思维过程和脑力活动</strong>所表现出来的综合能力，如感知观察能力、记忆能力、逻辑思维能力和语言表达能力等</p> <p><strong>智能包含的能力</strong></p> <ul> <li>感知能力</li> <li>记忆和思维能力</li> <li>学习和自适应能力</li> <li>行为能力 <br> <span class=arithmatex>\(\quad\)</span>1.含义：是人们对感知到的外界信息作出动作反应的能力<br> <span class=arithmatex>\(\quad\)</span>2.信息来源：由感知直接获得的外界信息经过思维加工后的信息。</li> </ul> <p><strong>人工智能的简单模型</strong></p> <p><img alt=image-20240926145246010 src=../../picture/image-20240926145246010.png></p> <p><strong>详细定义</strong>：人工智能是研究人类智能活动的规律，构造具有一定智能的<strong>人工系统</strong>，研究如何让<strong>计算机</strong>去完成以往需要人的智力才能胜任的工作，也就是研究如何应用计算机的软硬件来模拟人类某些智能行为的基本理论、方法和技术。</p> <p><strong>组织成四类的人工智能的若干定义</strong>：</p> <p><img alt=image-20241220131947277 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201319394.png></p> <p><strong>图灵测试</strong>：让一台计算机和测试者分开，通过键盘等装置实现询问，如果一台计算机能够让<span class=heti-skip><span class=heti-spacing> </span>30%<span class=heti-spacing> </span></span>的人误以为它是人而不是计算机，那么就通过了图灵测试。</p> <p><strong>为了设计能够通过图灵测试的机器，需要用到哪些人工智能技术？</strong></p> <ol> <li>计算机视觉技术：精确地完成各种自动识别</li> <li>机器学习技术：从大量数据中自动提炼知识、发现规律</li> <li>自然语言处理技术：赋予计算机人类般的文本处理能力</li> <li>语音识别技术：自动而准确地将人类的语音转变成文字</li> </ol> <p><strong>人工智能的基础</strong>：</p> <ul> <li>哲学：标出了<span class=heti-skip><span class=heti-spacing> </span>AI<span class=heti-spacing> </span></span>的大部分重要思想；</li> <li>数学：使<span class=heti-skip><span class=heti-spacing> </span>AI<span class=heti-spacing> </span></span>成为一门规范科学；</li> <li>经济学：决策理论；</li> <li>神经科学：网络，并行处理；</li> <li>心理学：认知理论；</li> <li>计算机工程：<span>AI<span class=heti-spacing> </span></span>的“载体”；</li> <li>控制论：反馈的思想；</li> <li>语言学：知识表示、语法</li> </ul> <p><strong>二十一世纪三大尖端技术</strong>：人工智能、基因工程、纳米科学</p> <p>★★★<strong>人工智能的历史</strong></p> <p><img alt=image-20230205115208118 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201323587.png></p> <p>★★★<strong>人工智能学派</strong>：</p> <ul> <li>符号学派：认为人的认知基元是符号，而且认知过程即符号操作过程。知识是信息的一种形式，是构成智能的基础人工智能的核心问题是知识表示、知识推理和知识运用</li> <li>连接学派：认为人的思维基元是神经元</li> <li>行为学派：认为智能取决于感知和行动，智能行为只能在现实世界中与周围环境交互作用而表现出来</li> </ul> <p><strong>人工智能的目标</strong>：近期目标：制造智能机器；长期目标：实现机器智能</p> <p><strong>人工智能的三个阶段</strong>：</p> <ol> <li>能存会算的计算智能</li> <li>能听会说、能看会认的感知智能</li> <li>能理解会思考的认知智能</li> </ol> <p><strong>人工智能、机器学习、深度学习的关系</strong>：机器学习是一种实现人工智能的方法，深度学习是一种实现机器学习的技术</p> <p><img alt=image-20230205120518228 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201323583.png></p> <p><strong>人工智能的研究内容</strong>：知识表示、自动推理和搜索算法、机器学习和知识获取、知识处理系统、自然语言理解、计算机视觉、智能机器人、自动程序设计等</p> <p><strong>人工智能的主要应用领域</strong>：专家系统、机器人、模式识别、计算机视觉、人工神经网络、自然语言理解、自动程序设计、博弈等</p> <p><strong>涉及学科：</strong>除了计算机科学以外，人工智能还涉及信息论、控制论、自动化、仿生学、生物学、心理学、数理逻辑、语言学、医学和哲学等多门学科。</p> <p><img alt=image-20241220132918967 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201329053.png></p> <h3 id=agent>智能<span><span class=heti-spacing> </span>AGENT</span><a class=headerlink href=#agent title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <h4 id=agent_1><span>AGENT<span class=heti-spacing> </span></span>的本质<a class=headerlink href=#agent_1 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <h5 id=_5>基本定义<a class=headerlink href=#_5 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>智能体（Agent<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：能够感知和动作的实体（任何独立的能够“思想”并可以同环境交互的实体都可以抽象为智能体）</p> <p><img alt=image-20240926145810456 src=../../picture/image-20240926145810456.png></p> <p>简单说，一个智能体就是从<strong>感知序列到动作</strong>的一个函数： <span class=arithmatex>\(f:P^* -&gt; A\)</span></p> <ul> <li> <p>感知信息：表示任何时刻<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>的感知输入。感</p> </li> <li> <p>知序列：<span>Agent<span class=heti-spacing> </span></span>收到的所有输入数据的完整历史。<br> <span class=arithmatex>\(\quad\)</span>Agent在任何时刻的行动选择，取决于到该时刻为止的整个感知序列。<br></p> </li> <li> <p><span>Agent<span class=heti-spacing> </span></span>函数：将任意给定感知序列映射到<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>的动作。可以描述<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>的行为。</p> </li> </ul> <h5 id=agentagent><span>Agent<span class=heti-spacing> </span></span>函数与<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>程序<a class=headerlink href=#agentagent title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <ul> <li><span>Agent<span class=heti-spacing> </span></span>函数：是一个抽象的数学表示</li> <li><span>Agent<span class=heti-spacing> </span></span>程序： 是<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>函数在某种物理体系上的具体实现</li> </ul> <p><strong>Example</strong></p> <p><img alt=image-20240926152028566 src=../../picture/image-20240926152028566.png></p> <ul> <li>世界：方格<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>和<span><span class=heti-spacing> </span>B</span></li> <li>感知：可以感知所处的方格（位置<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>、是否有灰尘（本地的状态）如：[A, Dirty]</li> <li>动作：向左移动、向右移动、吸取灰尘、什么也不做<span><span class=heti-spacing> </span>Left, Right, Suck, NoOp</span></li> <li><span>Agent<span class=heti-spacing> </span></span>函数（感知<span class=heti-skip><span class=heti-spacing> </span>-<span class=heti-spacing> </span></span>动作映射函数<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：如果当前地点有灰尘，则吸取。否则移动到另一地点。</li> </ul> <table> <thead> <tr> <th style="text-align: center;"><strong>感知序列</strong></th> <th style="text-align: center;"><strong>行动</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">[A, Clean]</td> <td style="text-align: center;">Right</td> </tr> <tr> <td style="text-align: center;">[A, Dirty]</td> <td style="text-align: center;">Suck</td> </tr> <tr> <td style="text-align: center;">[B, Clean]</td> <td style="text-align: center;">Left</td> </tr> <tr> <td style="text-align: center;">[B, Dirty]</td> <td style="text-align: center;">Suck</td> </tr> </tbody> </table> <h4 id=agent_2>评价<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>的行为<a class=headerlink href=#agent_2 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <ul> <li> <p>理性<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>是做事正确的智能体。<br> <span class=arithmatex>\(\quad\)</span>1.即Agent函数表格的右边都填写正确。<br> <span class=arithmatex>\(\quad\)</span>2.严谨定义：对于每一个可能的<strong>感知序列</strong>，根据已知的<strong>感知序列</strong>和内建的<strong>先验知识</strong>，理性<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>选择能使<strong>性能指标</strong>的期望值<strong>最大化的动作</strong>。<br></p> </li> <li> <p>性能度量（<span>Agent<span class=heti-spacing> </span></span>成功程度的标准<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：通常由理性<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>的设计者给出，根据实际在所处的环境中希望得到的结果来设计度量，而不是根据智能体表现的行为。 <br> <span class=arithmatex>\(\quad\)</span> 1.把Agent置于一个环境中后，它将针对收到的感知信息产生动作序列。 <br> <span class=arithmatex>\(\quad\)</span> 2.该动作序列引起环境历经一个状态序列。 <br> <span class=arithmatex>\(\quad\)</span> 3.如果环境的上述状态序列是想要的，则Agent的性能良好。<br></p> </li> <li> <p>理性的衡量依据：PEAS<br> <span class=arithmatex>\(\quad\)</span> 1.性能度量——performance<br> <span class=arithmatex>\(\quad\)</span> 2.agent对环境的先验知识——environment<br> <span class=arithmatex>\(\quad\)</span> 3. agent可以执⾏的动作——actions<br> <span class=arithmatex>\(\quad\)</span> 4.agent的感知序列——sensor<br></p> </li> <li> <p>理性不完美，理性不全知</p> </li> <li>理性智能体要会“学习”</li> <li>理性智能体要有“自主性”</li> </ul> <h4 id=_6>任务环境<a class=headerlink href=#_6 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <h5 id=_7>性质<a class=headerlink href=#_7 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <ul> <li>完全可观察与部分可观察<br> <span class=arithmatex>\(\quad\)</span> 1.完全可观察：智能体能获取环境的完整状态，智能体不需要内部维护来记录世界的状况</li> <li>确定性与随机<br> <span class=arithmatex>\(\quad\)</span> 2.确定性：环境的下一个状态完全取决于当前状态和智能体的行动<br> <span class=arithmatex>\(\quad\)</span> 3. 环境是确定的，除非有其它智能体活动的影响。<br></li> <li>片段式与延续式：行动的选择是否取决于当前片段</li> <li>静态与动态<br> <span class=arithmatex>\(\quad\)</span> 1.环境在智能体思考的时候是否会变化<br> <span class=arithmatex>\(\quad\)</span> 2.出租车驾驶是动态的；纵横字谜游戏是静态的<br> <span class=arithmatex>\(\quad\)</span> 3.半动态：环境本身不随时间的流逝而变化，但智能体的性能评价随时间变化；例如计时棋赛。<br></li> <li>离散与连续：智能体感知的信息和行动</li> <li>单智能体与多智能体</li> </ul> <p><strong>真实的世界</strong>是部分可观，随机的，延续式的，动态的，连续的，多智能体的。</p> <p>问题求解的环境是完全可观的，确定的，静态的，离散的。</p> <h4 id=agent_3><span>Agent<span class=heti-spacing> </span></span>的结构<a class=headerlink href=#agent_3 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>智能体<span class=heti-skip><span class=heti-spacing> </span>=<span class=heti-spacing> </span></span>体系结构<span class=heti-skip><span class=heti-spacing> </span>+<span class=heti-spacing> </span></span>程序</p> <ul> <li><span>AI<span class=heti-spacing> </span></span>的任务是设计智能体<strong>程序</strong>，实现把感知信息映射到行动的智能体<strong>函数<span><span class=heti-spacing> </span>f</span></strong></li> <li>体系结构为程序提供：<br> <span class=arithmatex>\(\quad\)</span> 1.来自传感器的感知信息<br> <span class=arithmatex>\(\quad\)</span> 2.运行程序<br> <span class=arithmatex>\(\quad\)</span> 3.把程序产生的行动送到执行器 <br></li> <li>所选择的程序必须适合体系结构</li> </ul> <details class=note open=open> <summary>判断题</summary> <div class="tabbed-set tabbed-alternate" data-tabs=3:1><input checked=checked id=__tabbed_3_1 name=__tabbed_3 type=radio><div class=tabbed-labels><label for=__tabbed_3_1>每个<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>函数都可以由机器<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>程序组合呈现</label></div> <div class=tabbed-content> <div class=tabbed-block></div> </div> </div> <p>False。受机器的运算能力和存储能力限制。<br></p> <div class="tabbed-set tabbed-alternate" data-tabs=4:1><input checked=checked id=__tabbed_4_1 name=__tabbed_4 type=radio><div class=tabbed-labels><label for=__tabbed_4_1>一个<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>函数可能对应多个<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>程序</label></div> <div class=tabbed-content> <div class=tabbed-block></div> </div> </div> <p>True。<span>Agent<span class=heti-spacing> </span></span>程序与运行平台关联<br></p> <div class="tabbed-set tabbed-alternate" data-tabs=5:1><input checked=checked id=__tabbed_5_1 name=__tabbed_5 type=radio><div class=tabbed-labels><label for=__tabbed_5_1>实现给定<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>函数的<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>程序是否可以有多个</label></div> <div class=tabbed-content> <div class=tabbed-block></div> </div> </div> <p>True。比如添加一些代理程序，只输入不会影响输出的空值。<br></p> <div class="tabbed-set tabbed-alternate" data-tabs=6:1><input checked=checked id=__tabbed_6_1 name=__tabbed_6 type=radio><div class=tabbed-labels><label for=__tabbed_6_1>给定一个固定的机器结构，任意<span class=heti-skip><span class=heti-spacing> </span>agent<span class=heti-spacing> </span></span>程序都会精确执行一个<span class=heti-skip><span class=heti-spacing> </span>agent<span class=heti-spacing> </span></span>函数吗？</label></div> <div class=tabbed-content> <div class=tabbed-block></div> </div> </div> <p>True。<span>agent<span class=heti-spacing> </span></span>的行为被结构和程序固定。<br></p> </details> <div class="admonition note"> <p class=admonition-title>设想我们现在保持<span class=heti-skip><span class=heti-spacing> </span>agent<span class=heti-spacing> </span></span>程序固定，但是我们加快机器运行速度为两倍，会影响<span class=heti-skip><span class=heti-spacing> </span>agent<span class=heti-spacing> </span></span>函数吗？</p> <p>答<span class=heti-skip><span class=heti-spacing> </span>:<span class=heti-spacing> </span></span>这取决于程序和环境。 如果环境是动态的，则加快机器速度可能意味着选择不同（也许更好）的动作。 如果环境是静态的，并且程序不在意运行时间，<span>agent<span class=heti-spacing> </span></span>函数保持不变。<br></p> </div> <h4 id=_8>智能体的（结构）类型<a class=headerlink href=#_8 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <h5 id=_9>分类<a class=headerlink href=#_9 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>简单反射型：基于当前感知、忽略历史感知<br></p> <p>基于模型的简单反射型：使用内部模型记录世界的当前状态，按反射型决策<br></p> <p>基于目标型：追踪记录世界状态、要达到的目标，选择导致达成目标的行为<br></p> <p>基于效用型：使用更普适的度量：效用函数，把状态映射到实数来描述与智能体与状态相关的高兴程<br></p> <ul> <li>每种<span class=heti-skip><span class=heti-spacing> </span>Agent<span class=heti-spacing> </span></span>程序都以特定的方式结合了特定的成分来生成行动</li> <li>所有这些智能体都可以转变为学习智能体，能够提高性能以便生成更好的行动</li> </ul> <h5 id=_10>简单反射智能体<a class=headerlink href=#_10 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <ul> <li>基于当前感知选择行动，忽略感知历史<br> <span class=arithmatex>\(\quad\)</span> 1.基于当前感知选择行动，忽略感知历史<br> <span class=arithmatex>\(\quad\)</span> 2.只有在可以仅根据当前感知信息来完成当前决策的情况下才能工作，即环境完全可观<br></li> </ul> <p><img alt=image-20240926184333777 src=../../picture/image-20240926184333777.png></p> <h5 id=_11>具有模型的反射智能体<a class=headerlink href=#_11 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <ul> <li>使用内部模型记录世界的当前状态，按反射型智能体方式选择行动</li> </ul> <p><img alt=image-20240926184340153 src=../../picture/image-20240926184340153.png></p> <h5 id=_12>基于目标的智能体<a class=headerlink href=#_12 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>追踪记录世界的状态、要达到的目标，并选择导致达成目标的行动</p> <p><img alt=image-20240926184344721 src=../../picture/image-20240926184344721.png></p> <h5 id=utility>基于效用（utility）的智能体<a class=headerlink href=#utility title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>使⽤更普适的度量：<strong>效⽤函数</strong>，把状态映射到实数来描述与智能体与状态相关的⾼兴程度</p> <p>效用函数可以辅助进行决策：</p> <ul> <li>有多个相互冲突的目标可达到时实现折中</li> <li>多个目标都不能有把握达到时选择一个目标</li> </ul> <p><img alt=image-20240926184354139 src=../../picture/image-20240926184354139.png></p> <h5 id=_13>学习智能体<a class=headerlink href=#_13 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <ul> <li>学习元件：负责改进，利用评论元件的反馈来评价智能体，并决定如何修改执行元件以将来做得更好</li> <li>执行元件：负责选择外部动作，接受感知信息并进行行动决策</li> <li>评论元件：根据固定的性能标准告诉学习元件智能体的运转情况如何</li> <li>问题产生器：负责提议可以导致新的和有信息价值的经验的行动</li> </ul> <p><img alt=image-20240926184748107 src=../../picture/image-20240926184748107.png></p> <p><span>Agent<span class=heti-spacing> </span></span>程序包含回答以下问题的部件：</p> <ul> <li>当前状态；</li> <li>当前应该采取的行动；</li> <li>行动后果</li> </ul> <p><strong>Agent</strong>程序内部状态及其转换表示：</p> <ol> <li>原子表示：没有内部结构的表示</li> <li>要素化表示：一个状态中包含多个要素（原子<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，即多个变量和特征的集合</li> <li>结构化表示：一个状态包含对象、每个对象可能有自身的特征值，以及与其他对象的关系</li> </ol> <p>智能体特性</p> <ul> <li>自主性</li> <li>反应性</li> <li>适应性</li> <li>社会性</li> </ul> <h4 id=_14>总结<a class=headerlink href=#_14 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <ul> <li>定义：智能体是可以感知环境并在环境中行动的某种东西。智能体函数指定智能体响应任何感知序列所采取的行动。</li> <li>性能度量评价智能体在环境中的行为表现。理性智能体的行动使其性能度量期望值最大化。</li> <li>任务环境包括性能度量、外部环境、执行器和传感器。设计智能体的第一步总是把任务空间定义得尽可能完全。</li> <li>任务环境的性质：变化的，完全可观察的？确定性的？片段式的？静态的？离散的？单智能体的？</li> <li>智能体程序是智能体函数的实现</li> <li>简单反射型智能体直接对感知信息作出反应</li> <li>基于模型的反射智能体保持内部状态，追踪记录当前感知信息中不明显的世界信息。</li> <li>基于目标的智能体的行动为了达到目标</li> <li>基于效用的智能体试图最大化自己期望的“快乐”</li> <li>所有智能体都可以通过学习来改进其性能</li> </ul> <details class=note open=open> <summary>课后习题——给出任务环境的<span class=heti-skip><span class=heti-spacing> </span>PEAS<span class=heti-spacing> </span></span>描述</summary> <div class="tabbed-set tabbed-alternate" data-tabs=7:4><input checked=checked id=__tabbed_7_1 name=__tabbed_7 type=radio><input id=__tabbed_7_2 name=__tabbed_7 type=radio><input id=__tabbed_7_3 name=__tabbed_7 type=radio><input id=__tabbed_7_4 name=__tabbed_7 type=radio><div class=tabbed-labels><label for=__tabbed_7_1>机器人足球运动员</label><label for=__tabbed_7_2>因特网购书智能体</label><label for=__tabbed_7_3>自主的火星漫游者</label><label for=__tabbed_7_4>数学家的定理证明助手</label></div> <div class=tabbed-content> <div class=tabbed-block> <p>表现度（Performance measure<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>： 胜利的标志，可能是进球的次数或比赛中采取的成功策略。<br> 环境（Environment）： 足球场地，包括球员、球、球场等。<br> 行动（Actuators）： 足球运动员可以执行的动作，如奔跑、传球、射门等。<br> 传感器（Sensors）： 用于感知球场状态、球的位置、其他球员的位置等信息<br></p> </div> <div class=tabbed-block> <p><span>P:<span class=heti-spacing> </span></span>成功购买所需书籍的效率，可能包括花费的金钱、购书的时间等。<br> E:因特网上的书店，包括书籍、价格、库存等信息。<br> A:购买、搜索、添加到购物车等在线购书的动作。<br> S:用于感知书店网站上的书籍信息、价格、用户的购物车状态等传感器。<br></p> </div> <div class=tabbed-block> <p><span>P:<span class=heti-spacing> </span></span>成功执行任务的效率和准确性，例如探测到的有趣地点数量、完成的科学实验等。<br> E:火星表面，包括地形、岩石、大气等。<br> A:移动、采集样本、拍摄照片等火星漫游任务的动作。<br> S:用于感知火星表面的传感器，包括摄像头、化学传感器、温度计等。<br></p> </div> <div class=tabbed-block> <p><span>P:<span class=heti-spacing> </span></span>成功证明定理的准确性和效率。<br> E:数学定理的领域，可能包括公理、已知定理、未证明的定理等。<br> A:推导、演绎、应用逻辑规则等进行定理证明的动作。<br> S:用于感知数学领域的信息，包括公理、已知定理、证明中的中间步骤等传感器。<br></p> </div> </div> </div> </details> <h3 id=_15>通过搜索进行问题求解<a class=headerlink href=#_15 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <h4 id=_16>基本概念<a class=headerlink href=#_16 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>★★★<strong>基于目标的智能体</strong>：智能体把目标信息和可能行动的结果信息结合起来，以选择达到目标的行动（决策<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。搜索和规划帮助智能体找到达到目标的行动序列。既追踪记录世界的状态，又记录要达到的目标集，并选择能达到目标的行动。</p> <p><strong>问题求解的步骤</strong>：目标形式化；问题形式化；搜索；执行。</p> <p><img alt=image-20241220142231077 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201422146.png></p> <p>★★★<strong>良定义的问题的组成部分形式化描述</strong>：初始状态<span><span class=heti-spacing> </span>s</span>、可能行动<span><span class=heti-spacing> </span>a</span>、转移模型、目标测试、路径耗散函数</p> <p><img alt=image-20241220142358924 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201423017.png></p> <p><strong>问题和解的类型</strong>：</p> <ul> <li>单一状态问题：确定的动作后果，完全可观。智能体知道自己处于什么状态；解是一个序列。</li> <li>构造问题：确定的动作后果，部分可观 。智能体不知道自己处于什么状态；解（如果存在的话）是一个序列。</li> <li>偶然事件问题：不确定的动作后果、部分可观。感知提供关于目前状态的最新信息，常常是搜索<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>执行交替进行。</li> <li>探索性问题：对状态空间一无所知 。</li> </ul> <p><strong>搜索</strong>：智能体问题的解（一个行动序列）需要通过搜索求解（考虑各种可能的行动序列<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。</p> <p>搜索是人工智能技术中进行问题求解的基本技术。</p> <p><strong>搜索的主要过程（三要素）</strong>：状态空间、后继函数、初始状态和目标测试</p> <ul> <li>状态空间：从初始或目的状态出发，并且将它作为当前状态。</li> <li>后继函数：扫描操作算子集，将适用当前状态的一些操作算子作用于当前状态而得到新的状态，并建立指向其父节点的指针。</li> <li>初始状态和目标测</li> </ul> <p><strong>搜索树</strong>：</p> <p>树是没有环的图；树的一个子节点只有一个父节点，所以树不是一个递归的数据结构。</p> <p>状态空间：利用状态变量和操作符号，表示系统或问题的有关知识的符号体系。状态空间四元组</p> <ol> <li>S ：状态集合。 </li> <li>O ：操作算子的集合。 </li> <li>S0 ：包含问题的初始状态，是<span class=heti-skip><span class=heti-spacing> </span>S<span class=heti-spacing> </span></span>的非空子集。</li> <li>G：若干具体状态或满足某些性质的路径信息描述。</li> </ol> <p>求解路径：从<span class=heti-skip><span class=heti-spacing> </span>S0<span class=heti-spacing> </span></span>节点到<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>节点的路径。</p> <p>状态空间的一个解：一个有限的操作算子序列。</p> <p><strong>节点的数据结构</strong>：</p> <ul> <li>n.STATE：状态空间中与该节点相对应的状态</li> <li>n.PARENT：父节点<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>即产生该节点的节点</li> <li>n.ACTION (from the parent to the node)：由父节点产生该节点所用的行动</li> <li><strong>n.PATH-COST：代价，从初始状态到达该节点路径消耗，g(n)</strong></li> </ul> <p><strong>节点和状态的区别</strong>：</p> <p><img alt=image-20230207002430571 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201443438.png></p> <p><strong>边缘</strong>（frontier<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：在任一给定时间点，所有待扩展的叶节点的集合。</p> <p>边缘是一个没有后继的节点集合，可用一个队列来表示：FIFO（先进先出）队列、LIFO（后进先出）栈、priority（优先级队列<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。</p> <p><img alt=image-20241220144359076 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201443148.png></p> <p><strong>探索集</strong>（closed<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：用于存储每个扩展过的节点。已扩展节点可以用哈希表实现，便于有效检查重复状态。</p> <p><img alt=image-20230207003025023 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201446228.png></p> <p><strong>树搜索算法</strong>：</p> <p>基本思想：通过对已探索状态生成后继来探索状态空间</p> <p>基本做法：先追随一个选择，搁置其它的，等到万一发现第一个选择不能通向问题的解时再考虑</p> <p>树搜索算法可能会导致状态的重复。图搜索比树搜索多维护了一个<span class=heti-skip><span class=heti-spacing> </span>explored<span class=heti-spacing> </span></span>队列，用来记录算法经过的节点，可以避免重复。两者都有的<span class=heti-skip><span class=heti-spacing> </span>frontier<span class=heti-spacing> </span></span>队列，则是用来记录将要探索的节点。</p> <p><img alt=image-20230207095615025 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201446233.png></p> <p><strong>搜索算法的性能度量</strong>：</p> <ul> <li><strong>完备性</strong>：有解时能否保证找到解</li> <li><strong>最优性</strong>：这个搜索策略是否能找到最优解</li> <li><strong>时间复杂度</strong>：根据搜索过程中产生的<strong>节点数目</strong>来度量，即找到解所花的时间</li> <li><strong>空间复杂度</strong>：在执行搜索的过程中需要的<strong>内存</strong>多少</li> </ul> <p><img alt=image-20230207100425542 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201446244.png></p> <p><strong>搜索方向和策略</strong>：</p> <p>搜索方向：数据驱动、目的驱动、双向搜索</p> <ul> <li>数据驱动：从初始状态出发的正向搜索，用给定数据中约束知识指导搜索</li> <li>目的驱动：从目的状态出发 的逆向搜索。哪些操作算子能产生该目的，产生目的时需要哪些条件</li> <li>双向搜索：直到两条路径在中间的某处汇合为止。</li> </ul> <p>搜索策略：盲目搜索、启发式搜索；按照扩展顺序不同分为<strong>广度优先</strong>和<strong>深度优先</strong></p> <h4 id=_17>盲目搜索<a class=headerlink href=#_17 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p><img alt=image-20241220144856970 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201448019.png></p> <h5 id=dfs>深度优先（DFS）<a class=headerlink href=#dfs title="anchor link to this section for reference">¶</a></h5> <p>队列：先进后出</p> <p>深度优先遍历主要思路是从图中一个未访问的顶点<span class=heti-skip><span class=heti-spacing> </span>V<span class=heti-spacing> </span></span>开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是<strong>不撞南墙不回头</strong>，先走完一条路，再换一条路继续走。</p> <p><img alt=90f80e5f92d149b8b81f8c2e2fb8fd34 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201515463.gif></p> <h5 id=bfs>广度优先（BFS）<a class=headerlink href=#bfs title="anchor link to this section for reference">¶</a></h5> <p>是<strong>没有权重</strong>的<span class=heti-skip><span class=heti-spacing> </span>Dijkstra<span class=heti-spacing> </span></span>算法</p> <p>队列：先进先出</p> <p><a href=https://blog.csdn.net/aliyonghang/article/details/128724989>广度优先搜索算法（BFS）</a></p> <p>图示：</p> <p><span>A<span class=heti-spacing> </span></span>为起点，<span>G<span class=heti-spacing> </span></span>为终点。一开始我们在起点<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>上，此时并不知道<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>在哪里。</p> <p><img alt=img src=../../picture/1bb5820bb9100c7123086a080f2c779b.png></p> <p>将可以从<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>直达的三个顶点<span><span class=heti-spacing> </span>B</span>、C、<span>D<span class=heti-spacing> </span></span>设为下一步的候补顶点。</p> <p><img alt=img src=../../picture/23eb3167fb9f227f792632cb8ba67ca8.png></p> <p>从候补顶点中选出一个顶点。优先选择最早成为候补的那个顶点，如果多个顶点同时成为候补，那么可以随意选择其中一个。</p> <p><img alt=img src=../../picture/01a4f4108a871dc164e6517676120f73.png></p> <p>假设选择<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>点为先进去的，此时的队列<span class=heti-skip><span class=heti-spacing> </span>[B C D]<span class=heti-spacing> </span></span>变为<span><span class=heti-spacing> </span>[C D]</span></p> <p><img alt=img src=../../picture/5e702bd0963309ed1593d3a4d33fe044.png></p> <p>移动到选中的顶点<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>上。此时我们在<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>上， 所以<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>变为红色，同时将已经搜索过的顶点变为橙色。</p> <p><img alt=img src=../../picture/7a5220e28bb6c6aa89a6e8829853e97e.png></p> <p>将可以从<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>直达的两个顶点<span class=heti-skip><span class=heti-spacing> </span>E<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>设为候补顶点并加入队列，变为<span><span class=heti-spacing> </span>[C D E F]</span></p> <p><img alt=img src=../../picture/8882353fe5fb1470b8d51b0bf9cb3aad.png></p> <p>此时，最早成为候补顶点的是<span class=heti-skip><span class=heti-spacing> </span>C<span class=heti-spacing> </span></span>和<span><span class=heti-spacing> </span>D</span>，我们选择了左边的顶点<span><span class=heti-spacing> </span>C</span>。</p> <p><img alt=img src=../../picture/a47bcccfe9f7a6bd862819d6d9c39b99.png></p> <p>移动到选中的顶点<span class=heti-skip><span class=heti-spacing> </span>C<span class=heti-spacing> </span></span>上。</p> <p><img alt=img src=../../picture/e21810fb145d3f37e82ae7fba1df8fe7.png></p> <p>将可以从<span class=heti-skip><span class=heti-spacing> </span>C<span class=heti-spacing> </span></span>直达的顶点<span class=heti-skip><span class=heti-spacing> </span>H<span class=heti-spacing> </span></span>设为候补顶点，并将<span class=heti-skip><span class=heti-spacing> </span>C<span class=heti-spacing> </span></span>移除队列，此时的队列<span><span class=heti-spacing> </span>[D E F H]</span>。 </p> <p><img alt=img src=../../picture/25371cf2d3d548018ea64f70f1249edb.png></p> <p>重复上述操作直到到达终点，或者所有的顶点都被遍历为止。 </p> <p><img alt=2.gif src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201517484.gif></p> <h5 id=dls>有限深度搜索<span><span class=heti-spacing> </span>(DLS)</span><a class=headerlink href=#dls title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p><span>DLS<span class=heti-spacing> </span></span>规定了<span class=heti-skip><span class=heti-spacing> </span>DFS<span class=heti-spacing> </span></span>的最大搜索深度，对于一个给定的常数<span><span class=heti-spacing> </span>l</span>，<span>DLS<span class=heti-spacing> </span></span>在到达这个深度之后就会放弃搜索，转而去探索<span class=heti-skip><span class=heti-spacing> </span>frontier<span class=heti-spacing> </span></span>中的其他节点。</p> <h5 id=ids>迭代加深搜索（IDS）<a class=headerlink href=#ids title="anchor link to this section for reference">¶</a></h5> <p><span>DLS<span class=heti-spacing> </span></span>规定了<span class=heti-skip><span class=heti-spacing> </span>DFS<span class=heti-spacing> </span></span>的最大搜索深度，对于一个给定的常数<span><span class=heti-spacing> </span>l</span>，<span>DLS<span class=heti-spacing> </span></span>在到达这个深度之后就会放弃搜索，转而去探索<span class=heti-skip><span class=heti-spacing> </span>frontier<span class=heti-spacing> </span></span>中的其他节点。</p> <p><img alt=cb98cc310bd5dfdefed983d8d9d24e82.png src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201525513.jpeg></p> <h5 id=bs>双向搜索<span><span class=heti-spacing> </span>(BS)</span><a class=headerlink href=#bs title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p><span>BS<span class=heti-spacing> </span></span>的假设是我们不仅可以从初始节点出发，同时还可以从目标节点出发，从而实现双向的搜索。</p> <p><span>BS<span class=heti-spacing> </span></span>的内部往往是由<span class=heti-skip><span class=heti-spacing> </span>BFS<span class=heti-spacing> </span></span>实现的，如果从初始节点和从目标节点的搜索都是<span><span class=heti-spacing> </span>BFS</span>，可以保证算法的最优。</p> <p>实际上，<span>BS<span class=heti-spacing> </span></span>就是将<span class=heti-skip><span class=heti-spacing> </span>BFS<span class=heti-spacing> </span></span>画的半径为<span class=heti-skip><span class=heti-spacing> </span>d<span class=heti-spacing> </span></span>的一个大圆，换成了半径为<span class=heti-skip><span class=heti-spacing> </span>d/2<span class=heti-spacing> </span></span>的两个小圆。</p> <p><img alt=image-20241220152734314 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201527381.png></p> <h5 id=ucs>一致代价搜索<span><span class=heti-spacing> </span>(UCS)</span><a class=headerlink href=#ucs title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>也就是<span class=heti-skip><span class=heti-spacing> </span>Dijkstra<span class=heti-spacing> </span></span>算法</p> <p><a href=https://blog.csdn.net/weixin_45021364/article/details/109746913>UCS</a></p> <p><a href="[https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.337.search-card.all.click&vd_source=ace17a48ec1787387c4c8d582e6808cb"><span>B<span class=heti-spacing> </span></span>站视频</a></p> <ul> <li>每次从未标记的节点中选取距离出发点最近的节点，标记，收录到最优路径集合中</li> <li>计算刚加入节点<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>的邻近节点<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>的距离，若<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>的距离<span class=heti-skip><span class=heti-spacing> </span>+A<span class=heti-spacing> </span></span>到<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>的距离小于<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>的距离，则更新<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>的距离</li> </ul> <p>例题如下</p> <p>首先用表格记录该店距离前面点的初始距离，起始的值都为无穷大，前面点都为空</p> <p><img alt=image-20241026163510021 src=../../picture/image-20241026163510021.png></p> <p>首先节点<span class=heti-skip><span class=heti-spacing> </span>0<span class=heti-spacing> </span></span>到<span><span class=heti-spacing> </span>0</span>，距离为<span><span class=heti-spacing> </span>0</span>，找到距离最小的值，为<span><span class=heti-spacing> </span>0</span>，加入已搜索节点，并标注前面点为<span><span class=heti-spacing> </span>0</span></p> <p><img alt=image-20241026163726960 src=../../picture/image-20241026163726960.png></p> <p>更新节点<span class=heti-skip><span class=heti-spacing> </span>0<span class=heti-spacing> </span></span>附件的节点<span class=heti-skip><span class=heti-spacing> </span>1<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>7<span class=heti-spacing> </span></span>的距离</p> <p><img alt=image-20241026163803202 src=../../picture/image-20241026163803202.png></p> <p>在未被加入已搜索节点的里面找到距离出发点最小的点，是<span class=heti-skip><span class=heti-spacing> </span>1<span class=heti-spacing> </span></span>点，将其加入已搜索点，并跟新<span class=heti-skip><span class=heti-spacing> </span>1<span class=heti-spacing> </span></span>节点周围的点的距离。</p> <p><img alt=image-20241026163948143 src=../../picture/image-20241026163948143.png></p> <p>依次类推，直到所有点都被搜索完成</p> <p><strong>优点</strong>: </p> <ul> <li><strong>准确性</strong><span>:<span class=heti-spacing> </span></span>总是能找到最短路径。</li> <li><strong>简单性</strong><span>:<span class=heti-spacing> </span></span>实现相对简单。</li> </ul> <p><strong>缺点</strong>: </p> <ul> <li><strong>效率较低</strong><span>:<span class=heti-spacing> </span></span>算法需要遍历图中的大多数节点，可能导致较高的计算成本。</li> <li><strong>实时性差</strong><span>:<span class=heti-spacing> </span></span>在动态环境中可能不适用，因为它不能快速适应环境的变化</li> </ul> <table> <thead> <tr> <th></th> <th>广度优先搜索</th> <th>深度优先搜索</th> <th>有限深度搜索</th> <th>迭代加深搜索</th> <th>一致代价搜索</th> <th>回溯搜索</th> </tr> </thead> <tbody> <tr> <td>完备性</td> <td>是（如果<span class=heti-skip><span class=heti-spacing> </span>b<span class=heti-spacing> </span></span>有限）</td> <td>否（<span>m<span class=heti-spacing> </span></span>有限）</td> <td>是（<span class=arithmatex>\(l\ge d\)</span><heti-adjacent class=heti-adjacent-half>）</heti-adjacent>；否（l&lt;d)</td> <td>是（如果<span class=heti-skip><span class=heti-spacing> </span>b<span class=heti-spacing> </span></span>有限）</td> <td>是（如果每步耗散都<span class=heti-skip><span class=heti-spacing> </span>&gt;=<span class=heti-spacing> </span></span>一个正值<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>否则进入死循环）</td> <td></td> </tr> <tr> <td>最优性</td> <td>否<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>是（如果每步耗散为<span><span class=heti-spacing> </span>1</span>，或路径耗散是深度的非递减函数）</td> <td>否（有可能错误地选择一条分支且沿着一条无限的路径走下去）</td> <td>否</td> <td>否<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>是（如果每步耗散为<span><span class=heti-spacing> </span>1</span>，或路径耗散是深度的非递减函数）</td> <td>是</td> <td></td> </tr> <tr> <td>时间复杂性</td> <td><span class=arithmatex>\(O(b^{d+1})\)</span>。运行时间：<span class=arithmatex>\(O(V+E)\)</span></td> <td><span class=arithmatex>\(O(b^m)\)</span>。如果<span class=heti-skip><span class=heti-spacing> </span>m<span class=heti-spacing> </span></span>比<span class=heti-skip><span class=heti-spacing> </span>d<span class=heti-spacing> </span></span>大很多，情况会很糟糕；如果存在很多解，则比广度优先快很多</td> <td><span class=arithmatex>\(O(b^{l})\)</span></td> <td><span class=arithmatex>\(O(b^{d})\)</span></td> <td><span class=arithmatex>\(O(b^{1+[C^*/\epsilon]})\)</span>（<span>C*<span class=heti-spacing> </span></span>为最优解代价，<span><span class=arithmatex>\(\epsilon\)</span><span class=heti-spacing> </span></span>为每个行动的最少代价）</td> <td></td> </tr> <tr> <td>空间复杂性</td> <td><span class=arithmatex>\(O(b^{d})\)</span></td> <td><span class=arithmatex>\(O(b^{m})\)</span></td> <td><span class=arithmatex>\(O(b^{l})\)</span></td> <td><span class=arithmatex>\(O(bd)\)</span></td> <td><span class=arithmatex>\(O(b^{1+[C^*/\epsilon]})\)</span></td> <td></td> </tr> </tbody> </table> <p>般来说，当搜索空间很大且解的深度未知时，迭代加深搜索是首选的盲目搜索方法。</p> <p>当每一步的耗散都相等时，广度优先搜索是最优的。</p> <p><strong>避免重复状态</strong>：将要扩展的节点与已扩展的节点比较，如果发现两条到达同一状态的路径，就抛弃其中一条。对于回溯搜索，还必须存储那些已扩展且没有后继叶子的节点。</p> <p>采用图搜索的方法：牢记走过的路；树搜索<span class=heti-skip><span class=heti-spacing> </span>+explored set(closed<span class=heti-spacing> </span></span>表<span><span class=heti-spacing> </span>)</span>，用它存储每个扩展过的节点。可以避免重复状态，但有时也会错过最优解</p> <details class=note open=open> <summary>课后习题</summary> <div class="tabbed-set tabbed-alternate" data-tabs=8:3><input checked=checked id=__tabbed_8_1 name=__tabbed_8 type=radio><input id=__tabbed_8_2 name=__tabbed_8 type=radio><input id=__tabbed_8_3 name=__tabbed_8 type=radio><div class=tabbed-labels><label for=__tabbed_8_1>地图染色问题</label><label for=__tabbed_8_2>猴子和香蕉问题</label><label for=__tabbed_8_3>传教士与野人问题</label></div> <div class=tabbed-content> <div class=tabbed-block> <p>初始状态：一个未染色的地图。<br> 目标测试：所有的地区都已染色，且相邻的地区颜色不同。<br> 后继函数：选择一个未染色的地区，给它染上一种未在其邻居中使用的颜色。<br> 耗散函数：可以是未染色的地区的数量<br></p> </div> <div class=tabbed-block> <p>初始状态：猴子在地面上，箱子分开放置，香蕉挂在房顶上。。<br> 目标测试：猴子得到了香蕉。<br> 后继函数：猴子可以移动到箱子或地面上，可以叠放箱子，可以爬上箱子，可以拿香蕉。<br> 耗散函数：可以是猴子到香蕉的距离<br></p> </div> <div class=tabbed-block> <p>三个传教士和三个野人在河的一边，还有一条能载一个人或者两个人的船。找到一个办法让所有的人都渡到河的另一岸，要求在任何地方野人数都不能多于传教士的人数（可以只有野人没有传教士）<br> a.<br> 状态(State)：出发时的初始状态、期望到达时的目标状态和每一次动作后的当前状态。在本例中用左岸传教士人数、左岸野人人数、右岸传教士人数、右岸野人人数、船的位置组成列表来表示状态：[ML, CL, MR, CR, B]，其中人数用数字表示数目，船的位置表示的方式很特殊：左岸为1，右岸为-1。<br> 动作(Action)：指一个状态可以执行的动作。在本例中即每次摆渡时，船载两种人分别的人数，比如说：[2, 1]表示载2个传教士，1个野人。<br> 转换模型：描述每个动作产生的结果，即Result(State, Action)，求出下一个状态。在本例中，[3, 3, 0, 0, 1]在动作[1, 1]造成的结果为[2, 2, 1, 1, -1]，所以通过模型Result()，将[3, 3, 0, 0, 1]转换为了[2, 2, 1, 1, -1]。<br> 目标测试(Goal test)：确定当前状态是否为目标状态。在本例中，[0, 0, M, C, -1]为目标状态，当每次经过转换模型后，应该对得到的状态进行目标测试。<br> 路径代价(Cost)：即每条路径的代价。在本例中，假设每次划船的代价是相同的，就可以用状态转移的次数来表示代价，次数越少的解越优。<br> <img alt=image-20241220154551898 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201545940.png><br> b.采用先深搜索、先广搜索以及图搜索都可以，注意检查重复状态，重复状态的检测避免程序陷入死循环。<br> c.虽然状态空间比较简单，但是要检测重复状态是一个困难；另外，在当前状态选取下一个合法状态，要能够不漏举所有合法状态也存在困难，当在某个状态无下一个合法状态时，需要回溯，这些都使得人为求解它变得困难。<br></p> </div> </div> </div> </details> <h4 id=_18>启发式搜索<a class=headerlink href=#_18 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <h5 id=_19>最好优先算法<a class=headerlink href=#_19 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>将⼀致代价搜索（每次取路径耗散<span class=heti-skip><span class=heti-spacing> </span>g(n)<span class=heti-spacing> </span></span>最小的拓展）的代价换成对希望值评估函数<span class=heti-skip><span class=heti-spacing> </span>f(n)<span class=heti-spacing> </span></span>的评估，每次搜索时优先扩展最有希望的未扩展节点（评估值最小的节点<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。</p> <p><strong>g(n)</strong>：从起始点到当前点<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>的实际耗散</p> <p><strong>h(n)</strong>：从当前点<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>到目标点的最小路径耗散估计</p> <p>​ 如果<span class=heti-skip><span class=heti-spacing> </span>h(n)<span class=heti-spacing> </span></span>从不高估到达目标的最低路径耗散值，称<span class=heti-skip><span class=heti-spacing> </span>h(n)<span class=heti-spacing> </span></span>是可容纳的，即<span class=heti-skip><span class=heti-spacing> </span>h(n)<span class=heti-spacing> </span></span>永远小于当前点到目标的实际最小耗散。</p> <p><strong>f(n)</strong>：从起始点经过当前点<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>到达目标点的路径最小耗散估计</p> <p><img alt=image-20241112210736622 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202411122107687.png></p> <p>目标节点的<span><span class=heti-spacing> </span>h(n)=0</span>，其实现：堆栈是一个按照期望递减顺序排列的队列。</p> <h5 id=_20>贪婪最好优先搜索<a class=headerlink href=#_20 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>f(n)=h(n)。搜索代价最小，效率高；使<span class=heti-skip><span class=heti-spacing> </span>h(n)<span class=heti-spacing> </span></span>最小化会对错误的起点较敏感</p> <h5 id=a><span>A*<span class=heti-spacing> </span></span>算法<a class=headerlink href=#a title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>与<span class=heti-skip><span class=heti-spacing> </span>Dijkstra<span class=heti-spacing> </span></span>的区别：是加了猜测<span class=heti-skip><span class=heti-spacing> </span>H<span class=heti-spacing> </span></span>函数的<span class=heti-skip><span class=heti-spacing> </span>Dijkstra<span class=heti-spacing> </span></span>算法</p> <ul> <li>Dijkstra: G(n)</li> <li>A*:F(n)=G(n)+H(n)</li> </ul> <p><a href=https://blog.csdn.net/Zhouzi_heng/article/details/115035298><span>A*<span class=heti-spacing> </span></span>讲解</a></p> <h6 id=the-search-area>搜索区域<span><span class=heti-spacing> </span>(The Search Area)</span><a class=headerlink href=#the-search-area title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h6> <p>以题目进行解释，我们假设某人要从<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>点移动到<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>点，但是这两点之间被一堵墙隔开。如图<span><span class=heti-spacing> </span>1</span> ，绿色是<span><span class=heti-spacing> </span>A</span> ，红色是<span><span class=heti-spacing> </span>B</span> ，中间蓝色是墙。</p> <p><img alt=img src=../../picture/0b78c760ac45ec2f8e30745201fecad7.jpeg></p> <p>格子的状态分为可走<span class=heti-skip><span class=heti-spacing> </span>(walkalbe)<span class=heti-spacing> </span></span>和不可走<span><span class=heti-spacing> </span>(unwalkable)</span></p> <h6 id=starting-the-search>开始搜索<span><span class=heti-spacing> </span>(Starting the Search)</span><a class=headerlink href=#starting-the-search title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h6> <ul> <li>从起点<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>开始，并把它就加入到一个由方格组成的<span class=heti-skip><span class=heti-spacing> </span>open list(<span class=heti-spacing> </span></span>开放列表<span class=heti-skip><span class=heti-spacing> </span>)<span class=heti-spacing> </span></span>中。 <span>Open list<span class=heti-spacing> </span></span>里的格子是路径可能会是沿途经过的，也有可能不经过。基本上<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>是一个<strong>待检查</strong>的方格列表。</li> <li>查看与起点<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>相邻的方格<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>忽略其中<span class=heti-skip><span class=heti-spacing> </span>unwalk<span class=heti-spacing> </span></span>的方格<span><span class=heti-spacing> </span>)</span> ，把其中可走的<span class=heti-skip><span class=heti-spacing> </span>(walkable)<span class=heti-spacing> </span></span>或可到达的<span class=heti-skip><span class=heti-spacing> </span>(reachable)<span class=heti-spacing> </span></span>方格也加入到<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中。把起点<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>设置为这些方格的父亲<span class=heti-skip><span class=heti-spacing> </span>(parent node<span class=heti-spacing> </span></span>或<span><span class=heti-spacing> </span>parent square)</span> 。</li> <li>把<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>从<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中移除，加入到<span class=heti-skip><span class=heti-spacing> </span>close list(<span class=heti-spacing> </span></span>封闭列表<span class=heti-skip><span class=heti-spacing> </span>)<span class=heti-spacing> </span></span>中， <span>close list<span class=heti-spacing> </span></span>中的每个方格都是现在不需要再关注的。</li> </ul> <p>如下图所示，深绿色的方格为起点，它的外框是亮蓝色，表示该方格被加入到了<span><span class=heti-spacing> </span>close list</span> 。与它相邻的黑色方格是需要被检查的，他们的外框是亮绿色。每个黑方格都有一个灰色的指针指向他们的父节点，这里是起点<span><span class=heti-spacing> </span>A</span> 。</p> <p><img alt=image002.jpg src=../../picture/c232b6a651f1a54116fa38e7b6de142a.jpeg></p> <h6 id=path-sorting>路径排序<span><span class=heti-spacing> </span>(Path Sorting)</span><a class=headerlink href=#path-sorting title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h6> <p>对每个节点，在计算时同时考虑两项<strong>代价</strong>指标：<strong>当前节点与起始点的距离</strong>，以及<strong>当前节点与目标点的距离</strong>：F = G + H</p> <ul> <li><strong>欧式距离</strong>：<span>G =<span class=heti-spacing> </span></span>从起点<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>移动到指定方格的移动代价，沿着到达该方格而生成的路径。</li> <li><span class=arithmatex>\(G = \sqrt{(x_1 - x_2)^2 +(y_1 - y_2)^2}\)</span> </li> <li><strong>曼哈顿距离</strong>：<span>H =<span class=heti-spacing> </span></span>从指定的方格移动到终点<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>的估算成本。</li> <li><span class=arithmatex>\(H = |x_1 - x_2| + |y_1 - y_2|\)</span></li> <li>注意，<span>H<span class=heti-spacing> </span></span>函数的选取要满足<strong>估算成本小于实际成本</strong></li> </ul> <p>计算起始点相邻方格的<span><span class=heti-spacing> </span>F</span>、G、<span>H<span class=heti-spacing> </span></span>的值，分别记录在左上角，左下角和右下角</p> <p><img alt=image003.jpg src=../../picture/908e62d12ad781ced1f767c945c1feda.jpeg></p> <h6 id=continuing-the-search>继续搜索<span><span class=heti-spacing> </span>(Continuing the Search)</span><a class=headerlink href=#continuing-the-search title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h6> <p>为了继续搜索，我们从<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中选择<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>值最小的<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>方格<span class=heti-skip><span class=heti-spacing> </span>)<span class=heti-spacing> </span></span>节点，然后对所选择的方格作如下操作：</p> <ul> <li>把它从<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>里取出，放到<span class=heti-skip><span class=heti-spacing> </span>close list<span class=heti-spacing> </span></span>中。</li> <li>检查所有与它相邻的方格，忽略其中在<span class=heti-skip><span class=heti-spacing> </span>close list<span class=heti-spacing> </span></span>中或是不可走<span class=heti-skip><span class=heti-spacing> </span>(unwalkable)<span class=heti-spacing> </span></span>的方格<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>比如墙，水，或是其他非法地形<span><span class=heti-spacing> </span>)</span> ，如果方格不在<span class=heti-skip><span class=heti-spacing> </span>open lsit<span class=heti-spacing> </span></span>中，则把它们加入到<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中。把我们选定的方格设置为这些新加入的方格的父亲。</li> <li>然后计算新加入的方格相对于当前处理方格的<span><span class=heti-spacing> </span>F</span>、G、<span>H<span class=heti-spacing> </span></span>值<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>注意<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>为累加值<span><span class=heti-spacing> </span>)</span></li> <li>选取其中<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>值最小的作为下一个待处理的方格。</li> <li>然后继续上面的操作。</li> <li>如果某个相邻的<strong>所有方格</strong>均已经在<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中，则检查所有方格所在的这条路径是否更优，也就是说经由当前方格<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>我们选中的方格<span class=heti-skip><span class=heti-spacing> </span>)<span class=heti-spacing> </span></span>到达那个方格是否具有更小的<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>值。</li> <li>如果没有，不做任何操作。</li> <li>相反，如果<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>值更小，则把那个方格的父亲设为当前方格<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>我们选中的方格<span><span class=heti-spacing> </span>)</span> ，然后重新计算那个方格的<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>值和<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>值。</li> </ul> <p><img alt=image004.jpg src=../../picture/10b76d7dfb9f62c0621f83409d472e23.jpeg></p> <ol> <li> <p>对于上图，在我们最初的<span class=heti-skip><span class=heti-spacing> </span>9<span class=heti-spacing> </span></span>个方格中，还有<span class=heti-skip><span class=heti-spacing> </span>8<span class=heti-spacing> </span></span>个在<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中，起点被放入了<span class=heti-skip><span class=heti-spacing> </span>close list<span class=heti-spacing> </span></span>中。在这些方格中，起点右边的格子的 <strong><span>F<span class=heti-spacing> </span></span>值<span class=heti-skip><span class=heti-spacing> </span>40<span class=heti-spacing> </span></span>最小</strong>，因此我们选择这个方格作为下一个要处理的方格。它的外框用蓝线打亮。</p> </li> <li> <p>首先，我们把它从<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>移到<span class=heti-skip><span class=heti-spacing> </span>close list<span class=heti-spacing> </span></span>中 。然后我们检查与它相邻的方格。它右边的方格是墙壁，我们忽略。它左边的方格是起点，在<span class=heti-skip><span class=heti-spacing> </span>close list<span class=heti-spacing> </span></span>中，我们也忽略。其他<span class=heti-skip><span class=heti-spacing> </span>4<span class=heti-spacing> </span></span>个<strong>相邻的方格均在<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中</strong>，因此我们需要检查经由这个方格到达那里的路径是否更好，使用<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>值来判定。让我们看看上面的方格。它现在的<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>值为<span><span class=heti-spacing> </span>14</span> 。如果我们经由当前方格到达那里， <span>G<span class=heti-spacing> </span></span>值将会为<span><span class=heti-spacing> </span>20</span>。显然<span class=heti-skip><span class=heti-spacing> </span>20<span class=heti-spacing> </span></span>比<span class=heti-skip><span class=heti-spacing> </span>14<span class=heti-spacing> </span></span>大，因此这不是最优的路径。</p> </li> <li> <p>当把<span class=heti-skip><span class=heti-spacing> </span>4<span class=heti-spacing> </span></span>个已经在<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中的相邻方格都检查后，<strong>没有发现经由当前方格的更好路径</strong>，因此我们不做任何改变。现在我们已经检查了当前方格的所有相邻的方格，并也对他们作了处理，是时候选择下一个待处理的方格了。</p> </li> <li> <p>因此再次遍历我们的<span><span class=heti-spacing> </span>open list</span> ，现在它只有<span class=heti-skip><span class=heti-spacing> </span>7<span class=heti-spacing> </span></span>个方格了，我们需要选择<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>值最小的那个。有趣的是，这次有两个方格的<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>值都<span><span class=heti-spacing> </span>54</span> ，选哪个呢？没什么关系。<strong>从速度上考虑，选择最后加入<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>的方格更快</strong>。</p> </li> <li> <p>我们选择起点右下方的方格，如下图所示</p> </li> </ol> <p><img alt=image005.jpg src=../../picture/19efd36ffafcb18f4a5af00078b07849.jpeg></p> <ol> <li> <p>只有三个方格可以选取，当前处理方格左边的方格，以及新加入的两个方格中。我们检查经由当前方格到达那里是否具有更小的<span class=heti-skip><span class=heti-spacing> </span>G<span class=heti-spacing> </span></span>值。没有。因此我们准备从<span class=heti-skip><span class=heti-spacing> </span>open list<span class=heti-spacing> </span></span>中选择下一个待处理的方格。</p> </li> <li> <p>以此类推，找到最短路径</p> </li> </ol> <p><img alt=image007.jpg src=../../picture/a2a101733a0277b4346f75b0c3efd89f.jpeg></p> <p>相关代码如下</p> <div class=highlight><pre><span></span><code><span class=k>def</span> <span class=nf>heuristic</span><span class=p>(</span><span class=n>a</span><span class=p>:</span> <span class=n>GridLocation</span><span class=p>,</span> <span class=n>b</span><span class=p>:</span> <span class=n>GridLocation</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
    <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>)</span> <span class=o>=</span> <span class=n>a</span>
    <span class=p>(</span><span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span> <span class=o>=</span> <span class=n>b</span>
    <span class=k>return</span> <span class=nb>abs</span><span class=p>(</span><span class=n>x1</span> <span class=o>-</span> <span class=n>x2</span><span class=p>)</span> <span class=o>+</span> <span class=nb>abs</span><span class=p>(</span><span class=n>y1</span> <span class=o>-</span> <span class=n>y2</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>a_star_search</span><span class=p>(</span><span class=n>graph</span><span class=p>:</span> <span class=n>WeightedGraph</span><span class=p>,</span> <span class=n>start</span><span class=p>:</span> <span class=n>Location</span><span class=p>,</span> <span class=n>goal</span><span class=p>:</span> <span class=n>Location</span><span class=p>):</span>
    <span class=n>frontier</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>()</span>
    <span class=n>frontier</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
    <span class=n>came_from</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=n>Location</span><span class=p>,</span> <span class=n>Optional</span><span class=p>[</span><span class=n>Location</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>
    <span class=n>cost_so_far</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=n>Location</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span> <span class=o>=</span> <span class=p>{}</span>
    <span class=n>came_from</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
    <span class=n>cost_so_far</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
    
    <span class=k>while</span> <span class=ow>not</span> <span class=n>frontier</span><span class=o>.</span><span class=n>empty</span><span class=p>():</span>
        <span class=n>current</span><span class=p>:</span> <span class=n>Location</span> <span class=o>=</span> <span class=n>frontier</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
        
        <span class=k>if</span> <span class=n>current</span> <span class=o>==</span> <span class=n>goal</span><span class=p>:</span>
            <span class=k>break</span>
        
        <span class=k>for</span> <span class=nb>next</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>neighbors</span><span class=p>(</span><span class=n>current</span><span class=p>):</span>
            <span class=n>new_cost</span> <span class=o>=</span> <span class=n>cost_so_far</span><span class=p>[</span><span class=n>current</span><span class=p>]</span> <span class=o>+</span> <span class=n>graph</span><span class=o>.</span><span class=n>cost</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=nb>next</span><span class=p>)</span>
            <span class=k>if</span> <span class=nb>next</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>cost_so_far</span> <span class=ow>or</span> <span class=n>new_cost</span> <span class=o>&lt;</span> <span class=n>cost_so_far</span><span class=p>[</span><span class=nb>next</span><span class=p>]:</span>
                <span class=n>cost_so_far</span><span class=p>[</span><span class=nb>next</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_cost</span>
                <span class=n>priority</span> <span class=o>=</span> <span class=n>new_cost</span> <span class=o>+</span> <span class=n>heuristic</span><span class=p>(</span><span class=nb>next</span><span class=p>,</span> <span class=n>goal</span><span class=p>)</span>
                <span class=n>frontier</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=nb>next</span><span class=p>,</span> <span class=n>priority</span><span class=p>)</span>
                <span class=n>came_from</span><span class=p>[</span><span class=nb>next</span><span class=p>]</span> <span class=o>=</span> <span class=n>current</span>
    
    <span class=k>return</span> <span class=n>came_from</span><span class=p>,</span> <span class=n>cost_so_far</span>

<span class=kn>from</span> <span class=nn>implementation</span> <span class=kn>import</span> <span class=o>*</span>
<span class=n>start</span><span class=p>,</span> <span class=n>goal</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>),</span> <span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=n>came_from</span><span class=p>,</span> <span class=n>cost_so_far</span> <span class=o>=</span> <span class=n>a_star_search</span><span class=p>(</span><span class=n>diagram4</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>goal</span><span class=p>)</span>
<span class=n>draw_grid</span><span class=p>(</span><span class=n>diagram4</span><span class=p>,</span> <span class=n>point_to</span><span class=o>=</span><span class=n>came_from</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=n>start</span><span class=p>,</span> <span class=n>goal</span><span class=o>=</span><span class=n>goal</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=n>draw_grid</span><span class=p>(</span><span class=n>diagram4</span><span class=p>,</span> <span class=n>path</span><span class=o>=</span><span class=n>reconstruct_path</span><span class=p>(</span><span class=n>came_from</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=n>start</span><span class=p>,</span> <span class=n>goal</span><span class=o>=</span><span class=n>goal</span><span class=p>))</span>
</code></pre></div> <h5 id=a-ida>迭代深入<span><span class=heti-spacing> </span>A</span><em> 搜索<span><span class=heti-spacing> </span>(IDA</span></em>)<a class=headerlink href=#a-ida title="anchor link to this section for reference">¶</a></h5> <p>基于迭代加深搜索的<span class=heti-skip><span class=heti-spacing> </span>A*<span class=heti-spacing> </span></span>算法，截断值是超过上一次迭代截断值的节点中最小的<span class=heti-skip><span class=heti-spacing> </span>f<span class=heti-spacing> </span></span>耗散值。更加实用，不需要判重和排序，空间需求减少</p> <p>由于<span class=heti-skip><span class=heti-spacing> </span>IDA *<span class=heti-spacing> </span></span>改成了深度优先的方式，相对于<span class=heti-skip><span class=heti-spacing> </span>A *<span class=heti-spacing> </span></span>算法，它的优点如下：</p> <ol> <li> <p>不需要判重，不需要排序，利于深度剪枝。</p> </li> <li> <p>空间需求减少：每个深度下实际上是一个深度优先搜索，不过深度有限制，使用<span class=heti-skip><span class=heti-spacing> </span>DFS<span class=heti-spacing> </span></span>可以减小空间消耗。</p> </li> <li> <h5 id=_21>缺点<a class=headerlink href=#_21 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> </li> <li> <p>重复搜索：即使前后两次搜索相差微小，回溯过程中每次深度变大都要再次从头搜索。</p> </li> </ol> <table> <thead> <tr> <th></th> <th>贪婪最好优先搜索</th> <th><span>A*<span class=heti-spacing> </span></span>搜索</th> </tr> </thead> <tbody> <tr> <td>完备性</td> <td>是（有限空间并采用重复状态检查）</td> <td>是（除非有无穷个<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(f(n)\leq f(G)\)</span><span class=heti-spacing> </span></span>的节点）</td> </tr> <tr> <td>最优性</td> <td>否</td> <td>是</td> </tr> <tr> <td>时间复杂性</td> <td><span class=arithmatex>\(O(b^{m})\)</span>，使用好的启发式函数会有改进</td> <td>以<span class=heti-skip><span class=heti-spacing> </span>[h<span class=heti-spacing> </span></span>的相对偏差<span class=heti-skip><span class=heti-spacing> </span>×<span class=heti-spacing> </span></span>解的深度<span class=heti-skip><span class=heti-spacing> </span>]<span class=heti-spacing> </span></span>为指数增长</td> </tr> <tr> <td>空间复杂性</td> <td><span class=arithmatex>\(O(b^{m})\)</span>，须将所有节点保存在存储器中</td> <td>须将所有节点保存在存储器中（空间复杂度高）</td> </tr> </tbody> </table> <p><strong>递归最好优先搜索（Recursive Best-First Search，RBFS）</strong>是一种用于解决问题的搜索算法，通常应用于图搜索和树搜索问题。<span>RBFS<span class=heti-spacing> </span></span>是对最好优先搜索（Best-First Search，BFS）的改进，它通过递归方式来实现。</p> <p>以下是<span class=heti-skip><span class=heti-spacing> </span>RBFS<span class=heti-spacing> </span></span>的详细描述：</p> <ol> <li> <p><strong>数据结构：</strong> <span>RBFS<span class=heti-spacing> </span></span>使用一个搜索树或图来表示问题的状态空间。每个节点都代表一个状态，而边表示状态之间的转移关系。每个节点都有一个估计的代价（启发式值）来指导搜索。</p> </li> <li> <p><strong>启发式函数：</strong> <span>RBFS<span class=heti-spacing> </span></span>依赖于一个启发式函数来估计每个节点的代价。这个函数根据问题的特定信息为每个节点分配一个值，用于判断搜索的方向。</p> </li> <li> <p><strong>递归：</strong> <span>RBFS<span class=heti-spacing> </span></span>通过递归的方式来实现。当搜索到一个节点时，它会按照最佳优先级（根据启发式值）展开该节点的子节点。如果子节点的估计代价超过了搜索的当前最优解，则<span class=heti-skip><span class=heti-spacing> </span>RBFS<span class=heti-spacing> </span></span>会回溯到父节点，并将当前最优解的估计代价更新为次优解的估计代价。</p> </li> <li> <p><strong>维护信息：</strong> 在递归调用中，<span>RBFS<span class=heti-spacing> </span></span>需要维护一些信息，包括当前搜索的最佳节点、次佳节点和它们的估计代价。这些信息在回溯时更新，并用于决定搜索的方向。</p> </li> <li> <p><strong>终止条件：</strong> <span>RBFS<span class=heti-spacing> </span></span>在搜索树中向下扩展，直到达到问题的目标状态。终止条件是根据具体问题来确定的，通常是检查当前节点是否是目标状态。</p> </li> <li> <p><strong>剪枝：</strong> <span>RBFS<span class=heti-spacing> </span></span>可以利用启发式函数来剪枝，以避免搜索不必要的状态。通过选择具有更有希望的启发式值的节点，<span>RBFS<span class=heti-spacing> </span></span>能够更快地达到目标。</p> </li> <li> <p><strong>复杂度：</strong> <span>RBFS<span class=heti-spacing> </span></span>的时间和空间复杂度取决于问题的状态空间的大小以及启发式函数的性能。</p> </li> </ol> <p><span>RBFS<span class=heti-spacing> </span></span>的优点在于其能够在有限内存条件下处理大规模状态空间，并且能够在启发式函数的引导下更快地找到最优解。然而，<span>RBFS<span class=heti-spacing> </span></span>的性能也受到启发式函数的影响，因此一个好的启发式函数对于算法的成功非常重要。</p> <p>算法分析：</p> <ul> <li> <p>如果<span class=heti-skip><span class=heti-spacing> </span>h<span class=heti-spacing> </span></span>是可采纳的，那么<span class=heti-skip><span class=heti-spacing> </span>RBFS<span class=heti-spacing> </span></span>是最优的</p> </li> <li> <p>空间复杂度是<span><span class=heti-spacing> </span>O</span>（bd)</p> </li> <li> <p>时间复杂度取决于启发函数的准确性以及扩展节点时改变最佳路径的频度</p> </li> <li> <p>但所利用内存太少了，没有充分利用内存，<span>MA*<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>SMA*<span class=heti-spacing> </span></span>能充分利用内存</p> </li> </ul> <p>★★★<strong>启发函数</strong>：假设<span><span class=heti-spacing> </span>A</span><em>算法生成的总节点数为<span><span class=heti-spacing> </span>N+1</span>（含起始节点<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，解的深度为<span><span class=heti-spacing> </span>d</span>，则<span><span class=heti-spacing> </span>b</span> </em>满足：</p> <p><span class=arithmatex>\(N+1 = 1+b^*+(b^*)^2+...+(b^*)^d\)</span></p> <p><strong>一个精心设计的启发函数的有效分支因子<span class=heti-skip><span class=heti-spacing> </span>b*<span class=heti-spacing> </span></span>应接近于<span><span class=heti-spacing> </span>1</span>。</strong></p> <p>启发函数的优劣：如果对于所有的节点<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>有<span><span class=heti-spacing> </span><span class=arithmatex>\(h_2(n)\geq h_1(n)\)</span></span>（都是可容许的<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，则<span class=heti-skip><span class=heti-spacing> </span>h2<span class=heti-spacing> </span></span>优于<span><span class=heti-spacing> </span>h1</span>。</p> <h5 id=_22>从松弛问题出发设计可采纳的启发函数：<a class=headerlink href=#_22 title="anchor link to this section for reference">¶</a></h5> <p>要点：松弛问题的最优解耗散不能超过真实问题的最优解耗散</p> <p>另一方案：从经验中学习启发式函数；</p> <p>递归最佳优先搜索（<span>RBFS)<span class=heti-spacing> </span></span>和简化存储限制<span><span class=heti-spacing> </span>A*</span>（<span>SMA*)<span class=heti-spacing> </span></span>是鲁棒、最优的搜索算法，只使用有限的内存。在时间足够的条件下，能求解<span class=heti-skip><span class=heti-spacing> </span>A*<span class=heti-spacing> </span></span>算法难以求解的问题。</p> <h4 id=_23>局部搜索<a class=headerlink href=#_23 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>不关心到达解的路径，只关心最终状态。从单独的一个当前状态出发，通常只移动到与之相邻的状态，并且不保留解的路径。</p> <p><strong>优点</strong>：需要很少的内存，经常能在很大或无限的状态空间中找到合理的解。</p> <h5 id=_24>爬山法<a class=headerlink href=#_24 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>每次都在临近的空间中选择最优解作为当前解，直到局部最优解。会陷入局部最优解。算法不会考虑与当前状态不相邻的状态，不维护搜索树，当前节点的数据结构只记录当前状态和目标函数值。</p> <p>改进：</p> <ul> <li>解决局部最优问题：每次不一定选择邻域内最优的点，而是依据一定概率，从邻域内选择一个点（指标函数优的点被选中概率大，指标函数差的点被选中的概率小<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。</li> </ul> <p>选择概率：最大值：<span class=arithmatex>\(P_{max}(x_i)=\frac{f(x_i)}{\sum f(x_j)} ,x_j\in N(x)\)</span></p> <p>​ 最小值：<span class=arithmatex>\(P_{min}(x_i)=\frac{1-P_{max}(x_i)}{\sum (1-P_{max}(x_j))}=\frac{1}{|N(x)-1|} (1-P_{max}(x_i)) ,x_j\in N(x)\)</span></p> <ul> <li>解决步长问题：变步长。</li> <li>解决起始点问题：随机的生成一些起始点，从每个起始点出发进行搜索，找到各自的最优解。再从这些最优解中选择一个最好的结果作为最终的结果。</li> </ul> <p><img alt=image-20230213153327943 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201640197.png></p> <ul> <li>随机爬山法：在上山移动中随机选择后继节点；被选中的概率可能随着上山移动的陡峭程度不同而不同。这种算法通常比最陡上升算法的收敛速度慢不少，但是在某些状态空间地形图上它能找到更好的解</li> <li>首选爬山法：基于随机爬山法，随机地生成后继节点直到生成一个优于当前节点的后继。当后继节点很多（比如上千个）是个好策略。</li> <li>随机重启爬山法：选择最优的状态作为后继节点，若该节点优于当前，则选择此状态为下一个状态；否则随机生成下一个状态（重启<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。该算法完备概率接近<span><span class=heti-spacing> </span>1</span>。</li> </ul> <h5 id=_25>模拟退火<a class=headerlink href=#_25 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>根据 <a href=http://oi-wiki.com/misc/hill-climbing/ >爬山算法</a> 的过程，我们发现：对于一个当前最优解附近的非最优解，爬山算法直接舍去了这个解。而很多情况下，我们需要去接受这个非最优解从而跳出这个局部最优解，即为模拟退火算法。</p> <div class="admonition note"> <p class=admonition-title>什么是退火</p> <p>退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。目的是降低硬度，改善切削加工性；消除残余应力，稳定尺寸，减少变形与裂纹倾向；细化晶粒，调整组织，消除组织缺陷。准确的说，退火是一种对材料的热处理工艺，包括金属材料、非金属材料。而且新材料的退火目的也与传统金属退火存在异同。<br></p> </div> <p>把爬山法和随机行走以某种方式结合，同时得到效率和完备性。通过允许一些“不好的”移动来避免陷入局部极小点处，但要逐步减小这些移动的幅度和频率。</p> <p><img alt=image-20241220164128888 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201641973.png></p> <p>随着温度的降低，跳跃越来越不随机，最优解也越来越稳定</p> <p><img alt=img src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201706909.gif></p> <div class=highlight><pre><span></span><code><span class=cp># 示例代码</span>
<span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;cmath&gt;</span>
<span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;cstdlib&gt;</span>
<span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;ctime&gt;</span>
<span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;iomanip&gt;</span>
<span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;iostream&gt;</span>

<span class=k>constexpr</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10005</span><span class=p>;</span>
<span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>[</span><span class=n>N</span><span class=p>],</span><span class=w> </span><span class=n>y</span><span class=p>[</span><span class=n>N</span><span class=p>],</span><span class=w> </span><span class=n>w</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
<span class=kt>double</span><span class=w> </span><span class=n>ansx</span><span class=p>,</span><span class=w> </span><span class=n>ansy</span><span class=p>,</span><span class=w> </span><span class=n>dis</span><span class=p>;</span>

<span class=kt>double</span><span class=w> </span><span class=nf>Rand</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>rand</span><span class=p>()</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>RAND_MAX</span><span class=p>;</span><span class=w> </span><span class=p>}</span>

<span class=kt>double</span><span class=w> </span><span class=nf>calc</span><span class=p>(</span><span class=kt>double</span><span class=w> </span><span class=n>xx</span><span class=p>,</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=n>yy</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=kt>double</span><span class=w> </span><span class=n>res</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=kt>double</span><span class=w> </span><span class=n>dx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>xx</span><span class=p>,</span><span class=w> </span><span class=n>dy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>yy</span><span class=p>;</span>
<span class=w>    </span><span class=n>res</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>sqrt</span><span class=p>(</span><span class=n>dx</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>dx</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>dy</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>dy</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>res</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>dis</span><span class=p>)</span><span class=w> </span><span class=n>dis</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>res</span><span class=p>,</span><span class=w> </span><span class=n>ansx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xx</span><span class=p>,</span><span class=w> </span><span class=n>ansy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>yy</span><span class=p>;</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>res</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=nf>simulateAnneal</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=kt>double</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>100000</span><span class=p>;</span>
<span class=w>  </span><span class=kt>double</span><span class=w> </span><span class=n>nowx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ansx</span><span class=p>,</span><span class=w> </span><span class=n>nowy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ansy</span><span class=p>;</span>
<span class=w>  </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>t</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mf>0.001</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=kt>double</span><span class=w> </span><span class=n>nxtx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nowx</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>Rand</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=w>    </span><span class=kt>double</span><span class=w> </span><span class=n>nxty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nowy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>Rand</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=w>    </span><span class=kt>double</span><span class=w> </span><span class=n>delta</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>calc</span><span class=p>(</span><span class=n>nxtx</span><span class=p>,</span><span class=w> </span><span class=n>nxty</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>calc</span><span class=p>(</span><span class=n>nowx</span><span class=p>,</span><span class=w> </span><span class=n>nowy</span><span class=p>);</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=n>delta</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>t</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>Rand</span><span class=p>())</span><span class=w> </span><span class=n>nowx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nxtx</span><span class=p>,</span><span class=w> </span><span class=n>nowy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nxty</span><span class=p>;</span>
<span class=w>    </span><span class=n>t</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mf>0.97</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=kt>double</span><span class=w> </span><span class=n>nxtx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ansx</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>Rand</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=w>    </span><span class=kt>double</span><span class=w> </span><span class=n>nxty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ansy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>Rand</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=w>    </span><span class=n>calc</span><span class=p>(</span><span class=n>nxtx</span><span class=p>,</span><span class=w> </span><span class=n>nxty</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>.</span><span class=n>tie</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>sync_with_stdio</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
<span class=w>  </span><span class=n>srand</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=w>  </span><span class=c1>// 注意，在实际使用中，不应使用固定的随机种子。</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=w> </span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>n</span><span class=p>;</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=w> </span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
<span class=w>    </span><span class=n>ansx</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=w> </span><span class=n>ansy</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=n>ansx</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>ansy</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>dis</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>calc</span><span class=p>(</span><span class=n>ansx</span><span class=p>,</span><span class=w> </span><span class=n>ansy</span><span class=p>);</span>
<span class=w>  </span><span class=n>simulateAnneal</span><span class=p>();</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>fixed</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>setprecision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>ansx</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=sc>' '</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>ansy</span>
<span class=w>            </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=sc>'\n'</span><span class=p>;</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h5 id=_26>遗传算法<a class=headerlink href=#_26 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>先将搜索结构编码为字符串形式，每个字符串结构被称为个体，然后对一组字符串结构（一个群体）进行循环操作。每次循环被称作一代，包括一个保存字符串中较优结构的过程和一个有结构的、随机的字符串间的信息交换过程。杂交和变异是算法的关键操作。</p> <p>与传统优化算法的不同点：遗传算法不是直接作用在参变量集上而是利用参变量集的某种编码；不是从单个点，而是从一个点的群体开始搜索；利用适应值信息，无须导数或其它辅助信息；<strong>利用概率转移规则，而非确定性规则</strong>。</p> <p>优越性：搜索过程中不易陷入局部最优，即使所定义的适应函数是不连续的、非规则的或有噪声的情况下也能以很大的概率找到整体最优解；由于并行性，非常适用于大规模并行计算机。</p> <p><img alt=image-20241220171258491 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201712557.png></p> <h4 id=_27>在线搜索<a class=headerlink href=#_27 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <ul> <li> <p>在线深度优先搜索：在线搜索中智能体只能扩展它实际占据的节点，因此搜索算法最好是局部扩展型的，如深度优先搜索。</p> </li> <li> <p>在线局部搜索：在线爬山搜索无法使用随机重新开始。可以避免局部极小值。替代方法之一是使用随机行走来探索环境；之二提高内存利用率。</p> </li> <li> <p>实时学习<span class=heti-skip><span class=heti-spacing> </span>A*<span class=heti-spacing> </span></span>算法。</p> </li> </ul> <p>不存在能够在所有可能的状态空间中都避免死路的算法</p> <div class="admonition note"> <p class=admonition-title>课后习题</p> <p>启发式路径算法是一个最佳优先搜索，它的目标函数是<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(f(n)=(2-w)g(n)+wh(n)\)</span>.<span class=heti-spacing> </span></span>算法中<span class=heti-skip><span class=heti-spacing> </span>w<span class=heti-spacing> </span></span>取什么值能保证算法是最优的？当<span class=heti-skip><span class=heti-spacing> </span>w=0<span class=heti-spacing> </span></span>时，这个算法是什么搜索？<span>w=1<span class=heti-spacing> </span></span>呢？<span>w=2<span class=heti-spacing> </span></span>呢？<br> <img alt=image-20241220180016675 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201800730.png><br></p> </div> <h3 id=_28>对抗搜索（博弈）<a class=headerlink href=#_28 title="anchor link to this section for reference">¶</a></h3> <h4 id=_29>基本概念<a class=headerlink href=#_29 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <ul> <li>在一个竞争的环境中，智能体之间通过竞争实现相反的利益，一方利益最大化，另一方最小化。</li> </ul> <p><strong>博弈的定义</strong>：竞争环境中多个<span class=heti-skip><span class=heti-spacing> </span>agent<span class=heti-spacing> </span></span>之间的目标是有冲突的，称为对抗搜索问题，也称为博弈</p> <p><strong>博弈类型</strong>：完全信息博弈，不完全信息博弈，概率博弈。</p> <p><strong>博弈问题形式化</strong>：初始状态、后继函数、终止测试、效用函数</p> <h5 id=_30>形式化<a class=headerlink href=#_30 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <ul> <li>初始状态：包括棋盘局面和确定该哪个游戏者出招</li> <li>后继函数：返回<span class=heti-skip><span class=heti-spacing> </span>(move, state)<span class=heti-spacing> </span></span>列表，每一项表示一个合法招数和对应的结果状态。</li> <li>终止测试：判断游戏是否结束。游戏结束的状态称为终止状态。</li> <li>效用函数：也称目标函数或收益函数，是终止状态的得分。国际象棋中赢、输、平分别是<span><span class=heti-spacing> </span>1</span>，<span>-1<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>0<span class=heti-spacing> </span></span>分，而围棋、黑白棋等可以有更多的结果。</li> </ul> <h5 id=game-tree>博弈数<span><span class=heti-spacing> </span>Game Tree</span><a class=headerlink href=#game-tree title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>可以理解为列举出所有的可能的结果</p> <h4 id=minmax><span>MINMAX<span class=heti-spacing> </span></span>算法<a class=headerlink href=#minmax title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>在每一步中，<span>MAX<span class=heti-spacing> </span></span>方选择所有节点中评估函数最大的节点作为当前的落棋选择，<span>MIN<span class=heti-spacing> </span></span>则相反。已知一个选择，<span>MAX<span class=heti-spacing> </span></span>将优先选择移动到一个有极大值的状态，而<span class=heti-skip><span class=heti-spacing> </span>MIN<span class=heti-spacing> </span></span>选择移动到有极小值的状态。</p> <p>根据深度优先生成整个博弈树，根据效用函数得到所有叶节点值，然后随着递归回溯，通过树把极小极大值回传。</p> <p>先列举出所有情况，并根据定义的得分准则，给最后一层赋分</p> <p><img alt=image-20241220185053755 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201850894.png></p> <p>之后，一层一层向上叠加，如果是<span><span class=heti-spacing> </span>Min</span>（对方选择<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，则其数值取其子节点中的最小值，如果是<span><span class=heti-spacing> </span>Max</span>（自己选择<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，则其数值取其子节点中的最大值</p> <p><img alt=image-20241220185224158 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201852258.png></p> <p>最后得到最上面的分数</p> <p><img alt=image-20241220185238159 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201852270.png></p> <table> <thead> <tr> <th></th> <th>极小极大策略</th> </tr> </thead> <tbody> <tr> <td>完备性</td> <td>是（如果树有限）</td> </tr> <tr> <td>最优性</td> <td>是（当对手总是最优时）</td> </tr> <tr> <td>时间复杂性</td> <td><span class=arithmatex>\(O(b^{m})\)</span>，<span>b<span class=heti-spacing> </span></span>为平均分支因子数</td> </tr> <tr> <td>空间复杂性</td> <td><span class=arithmatex>\(O(bm)\)</span></td> </tr> </tbody> </table> <p>极小极大算法将所有的子树全部扫描，会很浪费时间和空间。</p> <h4 id=-><span>α-β<span class=heti-spacing> </span></span>剪枝<a class=headerlink href=#- title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>从<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>方的角度来看：</p> <ul> <li>或节点：<span>MAX<span class=heti-spacing> </span></span>节点（ 扩展<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>方节点时<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>方可选择扩展最有利于自己的节点，只要可扩展的子节点中有一个对已有利， 则该节点就对已有利）</li> </ul> <p>与节点：<span>MIN<span class=heti-spacing> </span></span>节点（<span>MIN<span class=heti-spacing> </span></span>方必定选择最不利于<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>方的方式来扩展节点，只要<span class=heti-skip><span class=heti-spacing> </span>MIN<span class=heti-spacing> </span></span>方节点的子节点中有一个对<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>方不利，则该节点就对<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>方不利）</p> <ul> <li><span>α<span class=heti-spacing> </span></span>值：当前节点的子节点中的最大倒推值的下界。到目前为止路径上发现的<span class=heti-skip><span class=heti-spacing> </span>MAX<span class=heti-spacing> </span></span>的最佳（即极大值）选择。</li> </ul> <p><span>β<span class=heti-spacing> </span></span>值：当前节点的子节点中的最小倒推值的上界。到目前为止路径上发现的<span class=heti-skip><span class=heti-spacing> </span>MIN<span class=heti-spacing> </span></span>的最佳（即极小值）选择。</p> <p><span>Max<span class=heti-spacing> </span></span>层：<span class=arithmatex>\(α = max(α， 它的所有子结点的评价值)\)</span>，<span class=arithmatex>\(β = 它的父结点的β\)</span></p> <p><span>Min<span class=heti-spacing> </span></span>层：<span class=arithmatex>\(α = 它的父结点的α\)</span>，<span class=arithmatex>\(β = min(β， 它的所有子结点的评价值)\)</span></p> <p><strong><span>Max<span class=heti-spacing> </span></span>的<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>取大，<span>Min<span class=heti-spacing> </span></span>的<span class=heti-skip><span class=heti-spacing> </span>β<span class=heti-spacing> </span></span>取小（<span>α<span class=heti-spacing> </span></span>只增不减，<span>β<span class=heti-spacing> </span></span>只减不增<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>；</strong></p> <p><strong>当一个节点的所有子节点均完成遍历后，算出其倒推值；</strong></p> <p><strong>从上至下搜索时，将父节点的<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>β<span class=heti-spacing> </span></span>值传给该路径上所有节点；</strong></p> <p><strong>当某个节点的<span><span class=heti-spacing> </span><span class=arithmatex>\(α \geq β\)</span></span>，停止搜索该节点的其他子节点。</strong></p> <p><img alt=image-20241220190628795 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201906884.png></p> <ul> <li>剪枝不会影响最终的结果；<strong><span>α-β<span class=heti-spacing> </span></span>剪枝的效率很大程度上取决于检查后继的顺序</strong>，好的移动排放次序能够提高剪枝的效率（先检查那些可能最好的后继，时间复杂度从<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(O(b^m)\)</span><span class=heti-spacing> </span></span>减小到<span><span class=heti-spacing> </span><span class=arithmatex>\(O(b^{m/2})\)</span></span>。</li> <li>重复状态（调换）的解决方法：第一次遇见某棋局时将对它的评估值存储在哈希表中。</li> </ul> <h4 id=_31>截断搜索<a class=headerlink href=#_31 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <div class="admonition note"> <p class=admonition-title>Tip</p> <p>这是一种不完整的实时决策<br></p> </div> <p><span>α-β<span class=heti-spacing> </span></span>剪枝依然要搜索至少一部分空间直到终止状态，这样的搜索不现实。用可以估计棋局效用的启发式评估函数<span class=heti-skip><span class=heti-spacing> </span>EVAL<span class=heti-spacing> </span></span>代替效用函数，用是否到达截断处测试取代终止测试。</p> <ul> <li><strong>评估函数</strong>：计算简单；对非终止状态，评估函数应该和取胜的实际机会（几率）密切相关；评估函数对终止状态的排序与实际的效用函数相同。</li> </ul> <p>国际象棋中<span class=heti-skip><span class=heti-spacing> </span>EVAL<span class=heti-spacing> </span></span>通常取为加权线性函数：<span class=arithmatex>\(\sum_{i=1}^{n}w_if_i(s)\)</span></p> <p><strong>概率博弈</strong>：期望极小极大策略，通过计算全部子节点的平均效用来评价一个机会节点。时间复杂度为<span><span class=heti-spacing> </span><span class=arithmatex>\(O(b^mn^m)\)</span></span>，其中<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>为不同的掷骰子结果的数目。</p> <p>对于概率博弈使用类似<span class=heti-skip><span class=heti-spacing> </span>α-β<span class=heti-spacing> </span></span>剪枝：限制效用函数的取值范围，不用看机会节点的子节点就可以设置机会节点的值的上界。通过扩展极小极大值算法来处理，扩展后的算法其全部节点的平均效用来评价一个机会节点，平均效用值是每个节点的概率加权平均值。</p> <p><strong>不完全信息博弈</strong>：对每种牌局计算每个行为的最小最大值，然后选择对所有牌局期望值最高的行为。如果某个行为对所有的牌局都是最优的，则它是最优的。</p> <h3 id=_32>逻辑智能体<a class=headerlink href=#_32 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <h4 id=_33>基于知识的智能体<a class=headerlink href=#_33 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p><strong>推理</strong>：<span>AI<span class=heti-spacing> </span></span>的核心问题是推理，即研究怎样使计算机获得自动推理的能力</p> <ul> <li>概念：按照某种策略从<strong>已知事实</strong>出发去推出<strong>结论</strong>的过程</li> <li> <p>方法：</p> </li> <li> <p><strong>演绎推理</strong>：从已知的一般性知识出发，去推出蕴含在这些已知知识中的适合于某种个别情况的结论；一种<strong>由一般到个别</strong>的推理方法，核心是三段论。不能增加新知识。</p> </li> <li><strong>归纳推理</strong>：<strong>由个别到一般</strong>；可分为枚举、类比、统计、差异归纳推理等。是增加新知识的过程。</li> <li><strong>类比归纳推理</strong>：是指在两个或两类事物有许多属性都相同或相似的基础上，推出它们在其他属性上也相同或相似的一种归纳推理。</li> </ul> <p>控制策略：指如何使用领域知识使推理过程尽快达到目标的策略</p> <ul> <li> <p>推理策略：主要解决推理方向、冲突消解等问题</p> </li> <li> <p>推理方向控制策略：可分为正向推理、逆向推理、混合推理及双向推理</p> </li> <li> <p>求解策略：仅求一个解，还是求所有解或最优解等</p> </li> <li> <p>限制策略：对推理的深度、宽度、时间、空间等进行的限制</p> </li> <li> <p>冲突消解策略：指当有多条知识可用时，如何从多条可用知识中选出一条最佳知识用于推理的策略</p> </li> <li> <p>搜索策略</p> </li> </ul> <p><strong>逻辑智能体</strong>：基于知识的智能体，采用推理过程来得到关于新世界的表示，并用这些新表示推导下一步做什么。从通用的形式表达的知识中获益，通过对信息的组合和再组合，以适应各种用途。</p> <p><strong>在部分可观察的环境</strong>，能够将常识和当前的感知结合起来，在选择行动之前推导出当前状态的隐藏部分。</p> <p><strong>自然语言理解</strong>：要对隐含状态即说话者的意图进行推理。</p> <p><strong>基于知识的智能体（KBA）</strong>：核心构件是其知识库。用感知信息作为输入，并返回一个行动。</p> <ul> <li>知识库：一个语句（用知识表示语言表达，表示了关于世界的某些断言）集合，是用于信息系统中的结构化或非结构化数据的大型存储库。</li> </ul> <p>两类：Curated KBs（从维基百科和<span class=heti-skip><span class=heti-spacing> </span>WordNet<span class=heti-spacing> </span></span>等知识库中抽取大量的实体及实体关系，可以理解为是一种结构化的维基百科<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>；Extracted KBs（直接从上亿个网页中抽取实体关系三元组<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，实体关系和实体更多的是自然语言的形式，但是可能会存在一定噪音，其精确度要低于<span><span class=heti-spacing> </span>Curated KBs</span></p> <p>Tell：将新语句添加到知识库</p> <p>Ask：查询目前所知内容；当<span class=heti-skip><span class=heti-spacing> </span>Ask<span class=heti-spacing> </span></span>知识库一个问题时，答案必须遵循（follow）事先被告知的知识库的内容。</p> <ul> <li> <p>知识库问答：给定自然语言问题，通过对问题进行语义理解和解析，利用知识库进行查询、推理得出答案。</p> </li> <li> <p>基于知识的智能体必须能够：表达状态，动作等；合并新的感知；更新内部对世界的表达；演绎世界的隐藏特性；演绎合适的动作。</p> </li> </ul> <h4 id=_34>逻辑<a class=headerlink href=#_34 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p><strong>定义</strong>：用来表达信息的形式语言<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>是人们用以处理问题而抽象的一种思维规则或计算方法</p> <ul> <li>语法：定义语言中的语句怎样的表达是合法的</li> </ul> <p>语义：定义语句的“意思”。在标准逻辑中，语义定义了每条语句关于每种可能世界的真值，非真即假。</p> <ul> <li><strong>蕴涵</strong><heti-adjacent class=heti-adjacent-quarter>：</heti-adjacent>“如果…则…”，即一件事为真可得出另一件事也为真。</li> </ul> <p>α╞ β（语句<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>蕴涵语句<span><span class=heti-spacing> </span>β</span>）⇔ 使<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>为真的每个模型中，<span>β<span class=heti-spacing> </span></span>也为真</p> <p>KB ╞ <span>α (<span class=heti-spacing> </span></span>知识库<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>蕴涵语句<span><span class=heti-spacing> </span>α)</span> ⇔ 在<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>为真的所有模型中<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>也为真</p> <ol> <li> <p><strong>逻辑等价</strong>：任意两个语句<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>β<span class=heti-spacing> </span></span>是等价的当且仅当它们互相蕴涵时。α ⇔ β iff α╞ β and β╞ α</p> </li> <li> <p><img alt=image-20241220193920021 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412201939103.png></p> </li> <li> <p>★★★<strong>有效性</strong>：一个语句是有效的，如果在所有的模型中它都为真。</p> <p>演绎定理：对于任意语句<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>和<span><span class=heti-spacing> </span>β</span>，α╞ <span>β<span class=heti-spacing> </span></span>当且仅当语句（α⇒β）是有效的。</p> </li> <li> <p>★★★<strong>可满足性</strong>：一个语句是可满足的，如果对于部分模型它是真值。</p> </li> <li> <p><strong>模型</strong>：对“可能世界”的数学抽象。<span>m<span class=heti-spacing> </span></span>是<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>的一个模型，表示语句<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>在模型<span class=heti-skip><span class=heti-spacing> </span>m<span class=heti-spacing> </span></span>中为真，也称<span class=heti-skip><span class=heti-spacing> </span>m<span class=heti-spacing> </span></span>满足<span><span class=heti-spacing> </span>α</span>。用<span class=heti-skip><span class=heti-spacing> </span>M(α)<span class=heti-spacing> </span></span>表示满足<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>的所有模型。</p> </li> </ol> <p>α╞ β ⇔ M(α) ⊆ M(β)；KB ╞ α ⇔ M(KB) ⊆ M(α)。</p> <p>一个模型<span class=heti-skip><span class=heti-spacing> </span>m<span class=heti-spacing> </span></span>是一个知识库的模型当且仅当这个模型是知识库中所有句子的模型。</p> <p>一个知识库<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>是可满足的当且仅当这个知识库的模型<span class=heti-skip><span class=heti-spacing> </span>M(KB)<span class=heti-spacing> </span></span>是非空集合；一个知识库<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>是不可满足的当且仅当这个知识库的模型<span class=heti-skip><span class=heti-spacing> </span>M(KB)<span class=heti-spacing> </span></span>是空集。</p> <ul> <li><strong>推理</strong>：用蕴涵推导出结论。判断对于某些语句<span><span class=heti-spacing> </span>α</span>，KB╞<span>α<span class=heti-spacing> </span></span>是否成立</li> </ul> <p>模型检验：通过枚举所有可能的模型来检验<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>为真的情况下<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>都为真，即<span class=heti-skip><span class=heti-spacing> </span>M(KB)<span class=heti-spacing> </span></span>含于<span><span class=heti-spacing> </span>M(α)</span></p> <ol> <li>合理性：如果推理算法<span class=heti-skip><span class=heti-spacing> </span>i<span class=heti-spacing> </span></span>可以从<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>导出<span><span class=heti-spacing> </span>α</span>，我们表示为：<span class=arithmatex>\(KB|–_iα\)</span>，读为“<span>i<span class=heti-spacing> </span></span>从<span class=heti-skip><span class=heti-spacing> </span>KB<span class=heti-spacing> </span></span>导出<span><span class=heti-spacing> </span>α</span>”。只要<span><span class=heti-spacing> </span><span class=arithmatex>\(KB |–_iα\)</span></span>，KB ╞ <span>α<span class=heti-spacing> </span></span>就为真，则<span class=heti-skip><span class=heti-spacing> </span>i<span class=heti-spacing> </span></span>是合理的。</li> <li>可靠性：只导出蕴涵句的推理算法被称为可靠的。</li> <li>完备性：只要<span><span class=heti-spacing> </span>KB</span> ╞ α，<span><span class=arithmatex>\(KB |–_iα\)</span><span class=heti-spacing> </span></span>成立，如果推理算法可以生成任一蕴涵句，则完备（在有限的情况下确实完备，但是常常不完备<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>。</li> </ol> <p>简单推理：真值表枚举，时间复杂度为<span><span class=heti-spacing> </span><span class=arithmatex>\(O(2^n)\)</span></span>，空间复杂度<span><span class=heti-spacing> </span>$O(n) $</span>。</p> <ul> <li>语句是智能体的物理结构</li> <li>推理是从旧结构中创立新结构的过程</li> <li>逻辑推理应该确保新结构所代表的那部分世界的确是旧结构所代表的那部分的必然结论</li> </ul> <h4 id=_35>命题逻辑<a class=headerlink href=#_35 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <ul> <li><strong>命题</strong>：具有真假意义的陈述性语句。</li> <li>特点：陈述性、上下文无关、无歧义性、合成性。</li> <li>命题语言：是命题逻辑使用的形式语言，是符号的集合，用<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(Lp\)</span><span class=heti-spacing> </span></span>表示。</li> <li><strong>原子公式（文字）</strong>：命题语言中的一个表达式是原子公式，当且仅当它是一个命题符号。</li> <li><strong>原子语句</strong>：单个命题词组成，每个命题词代表一个真或假的命题</li> <li><strong>复合句</strong>：原子语句和逻辑连接词构造而成（优先级次序从高到低如下顺序）</li> <li><strong>文字</strong>：原子命题及其否定。</li> <li><strong>互补文字</strong>：一个文字是另一文字的否定。</li> <li><strong>子句</strong>：文字的析取式。单个文字可以被视为只有一个文字的析取式，也叫单元子句。</li> <li><strong>归并</strong>：去除文字的多余副本。</li> <li>语法：<img alt=image-20241112232612342 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202411122326413.png></li> </ul> <div class="admonition note"> <p class=admonition-title>Tips</p> <p>命题逻辑的优先级次序为（高到低<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：非、与、或、蕴含、当且仅当<br> 书写公式时，在不引起误解的情况下，可以省略部分小括号<br></p> </div> <p><strong>语义<span><span class=heti-spacing> </span>Semantics</span></strong></p> <p><img alt=image-20241220200047899 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412202000960.png></p> <p><strong>区分</strong></p> <p>（1）⇒（蕴含）是一个逻辑连接符，表示语言的一个组成部分 语句P⇒Q只有当P=true，Q=false时为False，其余为True。 P⇒Q等价于￢P∨Q 不要有P为真则Q为真的错觉 命题逻辑不要求P和Q之间存在相关性或因果关系。例如，语句“5是奇数蕴含北京是中国的首都”是命题逻辑的真语句</p> <p>（2）╞（蕴涵）表示推理，语句间的逻辑蕴涵关系 逻辑蕴涵关系类似于算术：语句x=0蕴涵了语句xy=0。 α╞β（蕴涵）当且仅当在使α为真的每个模型中，β也为真。 α╞β 当且仅当 M(α) ⊆ M(β)</p> <h4 id=_36>命题逻辑的推理模式<a class=headerlink href=#_36 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>与蕴涵相关的附加概念</p> <ul> <li>逻辑等价：如果两个语句在同样的模型集合中为真，则二者逻辑等价。</li> <li>有效性：一个语句是有效的，如果在所有的模型中它都为真。</li> <li>可满足性：一个语句是可满足的，如果对于部分模型它是真值。一个句子是不可满足的如果它在任何模型中都不为真。</li> </ul> <p>有效性与可满足性的关联</p> <ul> <li><span>α<span class=heti-spacing> </span></span>是有效的 当且仅当￢<span>α<span class=heti-spacing> </span></span>不可满足【￢<span>α<span class=heti-spacing> </span></span>不可满足，即在任何模型中￢<span>α<span class=heti-spacing> </span></span>都不为真，即在任何模型中<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>都为真，即<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>是有效的】</li> <li><span>α<span class=heti-spacing> </span></span>是可满足的当且仅当￢<span>α<span class=heti-spacing> </span></span>不是有效的【￢<span>α<span class=heti-spacing> </span></span>不是有效的，即不是在所有模型中￢<span>α<span class=heti-spacing> </span></span>都是真的，即在某些模型中￢<span>α<span class=heti-spacing> </span></span>是假的，即在某些模型中<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>是真的，即<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>是可满足的】</li> <li>α╞<span>β<span class=heti-spacing> </span></span>当且仅当语句<span><span class=heti-spacing> </span>(α</span>∧￢<span>β)<span class=heti-spacing> </span></span>是不可满足的。</li> </ul> <p><strong>推理规则</strong></p> <ol> <li> <p><strong>假言推理</strong>：<span><span class=arithmatex>\(\frac{α⇒β，α}{β}\)</span><span class=heti-spacing> </span></span>只要给定任何形式为<span><span class=heti-spacing> </span>α</span>⇒<span>β<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>α<span class=heti-spacing> </span></span>的语句，就可以推导出语句<span><span class=heti-spacing> </span>β</span>；无法从<span class=heti-skip><span class=heti-spacing> </span>β<span class=heti-spacing> </span></span>导出<span><span class=heti-spacing> </span>α</span></p> </li> <li> <p><strong>消去合成词</strong>：<span><span class=arithmatex>\(\frac{α∧β}{α}\)</span><span class=heti-spacing> </span></span>可以从合取式推导出任何合取子式。<span class=arithmatex>\(α∧β⇒β\)</span></p> </li> <li> <p>☆☆<strong>归结</strong>：选取一个子句（文字的析取式）和一个文字，生成一个新的子句，该新子句包含除了两个互补文字以外的原始子句中的所有文字。产生一个用于表示为合取范式的知识库的完备推理算法。</p> </li> </ol> <p>任何完备的搜索算法，只使用归结规则，就可以生成命题逻辑中被任何知识库蕴涵的任何结论。</p> <p><strong>归结原则</strong>：两两归结</p> <h3 id=_37>一阶逻辑<a class=headerlink href=#_37 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <p>★★★一个智能程序高水平的运行需要：<strong>事实知识</strong>（…是…<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>、<strong>规则知识</strong>（如果…则…<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>、<strong>控制知识</strong>（怎么做）和<strong>元知识</strong>（高层知识，怎么使用、解释规则等）</p> <p><strong>知识表示</strong>：认知科学和人工智能两个领域共同存在的问题</p> <p><strong>知识分类</strong>：</p> <ul> <li>范围。常识性知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>领域性知识</li> <li>作用。事实性知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>过程性知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>控制知识</li> <li>确定。确定性知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>不确定性知识</li> <li>表现。逻辑性知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>形象性知识</li> <li>抽象。零级知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>一级知识<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>二级知识</li> </ul> <p><strong>表示语言</strong>：自然语言、形式语言</p> <p><img alt=image-20241221085907844 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210859949.png></p> <h4 id=_38>命题逻辑基本概念<a class=headerlink href=#_38 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p>命题（proposition<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：是具有真假意义的语句。命题代表人们进行思维时的一种判断，或者是否定，或者是肯定。可以用命题符号表示</p> <p>但是：</p> <ul> <li>无法把不同事物间的共同特征表达出来。</li> <li>无法把所描述的客观事物的结构及逻辑特征反映出来。</li> </ul> <p>在表示命题时，既表示出主语<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>主词<span><span class=heti-spacing> </span>)</span>，也表示出谓语<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>谓词<span><span class=heti-spacing> </span>)</span>，就可以解决上述问题。这就提出了谓词<span class=heti-skip><span class=heti-spacing> </span>predicate<span class=heti-spacing> </span></span>的概念。</p> <p>命题内部逻辑结构的分解 →对判断的分解<span><span class=heti-spacing> </span>:</span></p> <ul> <li>把判断中的具体内容抽出，称为个体；</li> <li>剩下的判断即为谓词<span><span class=heti-spacing> </span>predicate</span></li> </ul> <p><strong>一阶谓词逻辑（FOL）</strong>：结合形式语言和自然语言的优势：采用命题逻辑的基础—陈述式、上下文无关、无歧义和合成语义，并借用自然语言的思想，构造更具表达能力的逻辑。一阶逻辑语言是围绕<strong>对象和关系</strong>建立起来的。</p> <p><strong>一阶谓词</strong>：</p> <ul> <li> <p>一阶逻辑的结构：论域、个体、个体间关系、作用于个体函数</p> </li> <li> <p>个体词：能够独立存在的事物，称之为客体或个体。</p> </li> <li> <p><strong>谓词</strong>：一阶形式语言中用于指称论域中个体的性质或者个体之间关系的形式符号。当谓词中的变元都用特定的个体取代时，谓词就具有一个确定的真假值。</p> </li> </ul> <p><strong><span>n<span class=heti-spacing> </span></span>元谓词</strong>：<span><span class=arithmatex>\(P(x_1,x_2,…,x_n)\)</span><span class=heti-spacing> </span></span>是<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>元谓词，当它有<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>个相互独立的自由变元；若对其中<span class=heti-skip><span class=heti-spacing> </span>k<span class=heti-spacing> </span></span>个变元进行约束则成为<span class=heti-skip><span class=heti-spacing> </span>n-k<span class=heti-spacing> </span></span>元谓词。如：<img alt=image-20230214104234194 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210903771.png style=zoom:56%;>。</p> <p><strong>一阶谓词</strong>：在<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>元谓词<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(P(x_1,x_2,…,x_n)\)</span><span class=heti-spacing> </span></span>中，若每个个体均为常量、变元或函数，则称它为一阶谓词。</p> <ul> <li> <p><strong>变量</strong>：表示论域内的任意一个个体</p> </li> <li> <p><strong>约束变量</strong>：量词辖域中<span class=heti-skip><span class=heti-spacing> </span>x<span class=heti-spacing> </span></span>的变量</p> </li> <li> <p><strong>自由变量</strong>：不在量词辖域内的变量</p> <p>自由变量可代入常量，约束变量不行；约束变量可改名（更改范围是量词中的指导变量，以及该量词作用域中所出现的该变量<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>，自由变量不行。</p> </li> </ul> <p><strong>常量</strong>：表示确定的个体</p> <ul> <li><strong>函数</strong>：表达个体之间的对应关系，用形如<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(f(x_1,x_2,…,x_n)\)</span><span class=heti-spacing> </span></span>来表示个体变元对应的个体<span><span class=heti-spacing> </span>y</span>，并称之为<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>元个体函数，简称函数。</li> </ul> <p>谓词和函数的区别：谓词代表语句，结果是真假；函数代表关系运算，结果是一个新个体。</p> <ul> <li>首字母大写：谓词</li> </ul> <p>首字母小写：函数、变量、常量</p> <p><strong>一阶谓词</strong>：在<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>元谓词<span><span class=heti-spacing> </span>P(x1</span>，X2，…<span>xn)<span class=heti-spacing> </span></span>中，若每个个体均为常量、变元或函数，则称它为一阶谓词。</p> <p>如果某个个体本身又是一个一阶谓词，则称它为二阶谓词，如此类推</p> <p><strong>量词</strong>：在命题中表示对客体数量化的词。</p> <ul> <li> <p><strong>全称量词</strong>：表示“对个体域中所有的（或任一个）个体” 。记为</p> </li> <li> <p><strong>存在量词</strong>：表示“在个体域中存在个体”。记为<span><span class=heti-spacing> </span><span class=arithmatex>\(\exists x\)</span></span></p> </li> <li> <p>任意后跟蕴含式，存在后跟合取式：<span class=arithmatex>\(\forall x\)</span></p> </li> </ul> <p>例子</p> <p>如<heti-adjacent class=heti-adjacent-quarter>：</heti-adjacent>“凡是人都有名字” 用M（x）表示“x是人”，N（x）表示“x有名字” $forall x（M（x） → N（x）） $</p> <p><strong>量词不能颠倒先后顺序，否则会改变公式的含义。</strong></p> <p>从约束变元的概念可以看出，P(x1,x2,…<span>xn)<span class=heti-spacing> </span></span>是<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>元谓词，它有<span class=heti-skip><span class=heti-spacing> </span>n<span class=heti-spacing> </span></span>个相互独立的自由变元，若对其中<span class=heti-skip><span class=heti-spacing> </span>k<span class=heti-spacing> </span></span>个变元进行约束则成为<span class=heti-skip><span class=heti-spacing> </span>n-k<span class=heti-spacing> </span></span>元谓词，因此，谓词公式中如果没有自由变元出现，则该式就成为一个命题。</p> <p>例如</p> <p><span>$ forall x ,P(x,y,z)$<span class=heti-spacing> </span></span>是二元谓词。</p> <p><span><span class=arithmatex>\(\exists y, \forall x ,P(x,y,z)\)</span><span class=heti-spacing> </span></span>是一元谓词。 </p> <h4 id=_39>一阶逻辑谓词逻辑<a class=headerlink href=#_39 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p><img alt=image-20241221092338554 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210923598.png></p> <p><img alt=image-20241221092417545 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210924585.png></p> <div class="admonition note"> <p class=admonition-title>Attention</p> <p>（1）个体常元和变元都是项。<br> （2）f是n元函数符号，若t1，t2，…，tn是项，则f（ t1，t2，…， tn ）是项。<br></p> </div> <p><img alt=image-20241221092845553 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210928599.png></p> <h5 id=_40>合取范式<a class=headerlink href=#_40 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p><img alt=image-20241221092924087 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210929135.png></p> <h5 id=_41>析取范式<a class=headerlink href=#_41 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p><img alt=image-20241221092943829 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210929874.png></p> <p>合适公式<span><span class=heti-spacing> </span>(WFF,Well-formedFormulas):</span></p> <p>通常把合适公式叫做谓词公式<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>递归定义如下<span><span class=heti-spacing> </span>:</span></p> <ul> <li>原子谓词公式是合适公式</li> <li>若<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>为合适公式<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>则一<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>也是一个合适公式</li> <li>若<span class=heti-skip><span class=heti-spacing> </span>A,B<span class=heti-spacing> </span></span>是合适公式<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>则<span class=heti-skip><span class=heti-spacing> </span>AvB,A<span class=heti-spacing> </span></span>入<span><span class=heti-spacing> </span>B,A=&gt;B,A</span>→<span>B<span class=heti-spacing> </span></span>也都是合适公式</li> <li>若<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>是合适公式<span class=heti-skip><span class=heti-spacing> </span>,x<span class=heti-spacing> </span></span>为<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>中的自由变元<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>则<span class=heti-skip><span class=heti-spacing> </span>(Vx)A<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>(<span class=heti-spacing> </span></span>日<span class=heti-skip><span class=heti-spacing> </span>x)A<span class=heti-spacing> </span></span>都是合适公式</li> <li>只有按上述规则<span class=heti-skip><span class=heti-spacing> </span>(1)<span class=heti-spacing> </span></span>至<span class=heti-skip><span class=heti-spacing> </span>(4)<span class=heti-spacing> </span></span>求得的那些公式<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>才是合适公式。</li> </ul> <h5 id=_42>等词<a class=headerlink href=#_42 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>除了使用谓词和项产生原子语句之外，一阶逻辑还有另一种构造原子语句的方式。可以用等词（等号<span><span class=heti-spacing> </span>=</span>）来表声明两个项指代同一个对象。</p> <p>可用于表述关于一个给定函数的事实：father(John)= Henry</p> <h5 id=_43>一阶逻辑的真值<a class=headerlink href=#_43 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h5> <p>只有当其对应的语句在定义域内为真时<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>才具有值<span class=heti-skip><span class=heti-spacing> </span>T(<span class=heti-spacing> </span></span>真<span class=heti-skip><span class=heti-spacing> </span>);<span class=heti-spacing> </span></span>而当其对应的语句在定义域内为假时<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>该原子公式才具有值<span class=heti-skip><span class=heti-spacing> </span>F(<span class=heti-spacing> </span></span>假<span><span class=heti-spacing> </span>)</span>。</p> <p>性质：</p> <ul> <li><strong>永真性</strong>：如果谓词公式<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>对个体域<span class=heti-skip><span class=heti-spacing> </span>D<span class=heti-spacing> </span></span>上的任何一个解释都取得真值<span><span class=heti-spacing> </span>T</span>，则称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>在<span class=heti-skip><span class=heti-spacing> </span>D<span class=heti-spacing> </span></span>上是永真的<span class=heti-skip><span class=heti-spacing> </span>;<span class=heti-spacing> </span></span>如果<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>在每个非空个体域上均永真，则称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>永真；如果谓词公式<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>对个体域<span class=heti-skip><span class=heti-spacing> </span>D<span class=heti-spacing> </span></span>上的任何一个解释都取得真值<span><span class=heti-spacing> </span>F</span>，则称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>在<span class=heti-skip><span class=heti-spacing> </span>D<span class=heti-spacing> </span></span>上是永假的<span class=heti-skip><span class=heti-spacing> </span>;<span class=heti-spacing> </span></span>如果<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>在每个非空个体域上均永假，则称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>永假。<span>(T<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>F<span class=heti-spacing> </span></span>是谓词逻辑真值表的<span class=heti-skip><span class=heti-spacing> </span>True<span class=heti-spacing> </span></span>和<span><span class=heti-spacing> </span>False)</span></li> <li><strong>可满足性<span class=heti-skip><span class=heti-spacing> </span>/<span class=heti-spacing> </span></span>不可满足性</strong>：对于谓词公式<span><span class=heti-spacing> </span>P</span>，如果至少存在一个解释使得<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>在此解释下的真值为<span><span class=heti-spacing> </span>T</span>，则称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>是可满足的；否则，则称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>是不可满足的。</li> <li><strong>等价性</strong>：给定任何两个谓词公式<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>和<span><span class=heti-spacing> </span>B</span>，设它们有共同的个体域<span><span class=heti-spacing> </span>E</span>，若对<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>的任一组变元进行赋值，所得命题的真值相同，则称谓词公式<span class=heti-skip><span class=heti-spacing> </span>A<span class=heti-spacing> </span></span>和<span class=heti-skip><span class=heti-spacing> </span>B<span class=heti-spacing> </span></span>在<span class=heti-skip><span class=heti-spacing> </span>E<span class=heti-spacing> </span></span>上是等价的，记作：A⇔B<heti-adjacent class=heti-adjacent-half>。</heti-adjacent>（不等同与等词）</li> </ul> <p><strong>永真蕴含</strong>：对于谓词公式<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>与<span><span class=heti-spacing> </span>Q</span>，如果<span><span class=heti-spacing> </span>P</span>→<span>Q<span class=heti-spacing> </span></span>永真，则称公式<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>永真蕴含<span><span class=heti-spacing> </span>Q</span>，且称<span class=heti-skip><span class=heti-spacing> </span>Q<span class=heti-spacing> </span></span>为<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>的逻辑结论，称<span class=heti-skip><span class=heti-spacing> </span>P<span class=heti-spacing> </span></span>为<span class=heti-skip><span class=heti-spacing> </span>Q<span class=heti-spacing> </span></span>的前提，记为<span><span class=heti-spacing> </span>P</span>⇒Q。</p> <h5 id=_44>翻译（符号化）<a class=headerlink href=#_44 title="anchor link to this section for reference">¶</a></h5> <p>把一个文字叙述的命题用谓词公式表示出来的过程称为谓词逻辑翻译或符号化<span class=heti-skip><span class=heti-spacing> </span>,<span class=heti-spacing> </span></span>其一般步骤如下<span><span class=heti-spacing> </span>:</span></p> <p>① 正确理解给定命题，必要时可适当加以改叙使其中的原子命题的关系更明显；</p> <p>② 把每个原子命题分解成个体，谓词和量词，在全总个体域中讨论时要给出特性谓词；</p> <p>③ 找出适当量词，注意<span class=heti-skip><span class=heti-spacing> </span><span class=arithmatex>\(\forall\)</span><span class=heti-spacing> </span></span>后跟蕴涵式，<span><span class=arithmatex>\(\exists\)</span><span class=heti-spacing> </span></span>后跟合取式。 </p> <h4 id=_45>谓词逻辑归结原理<a class=headerlink href=#_45 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h4> <p><span class=arithmatex>\([(p∨q)∧(﹁p∨r)]⇒(q∨r)\)</span></p> <p>利用归结原理证明命题公式的思路<heti-adjacent class=heti-adjacent-half>：</heti-adjacent>（类似反证法）</p> <ul> <li> <p>先求出要证明的命题公式的否定式的字句集<span><span class=heti-spacing> </span>S;</span></p> </li> <li> <p>然后对字句集（一次或者多次）使用归结原理；</p> </li> <li> <p>若在某一步推出了空字句，即推出了矛盾，则说明字句集<span class=heti-skip><span class=heti-spacing> </span>S<span class=heti-spacing> </span></span>是不可满足的，从而原否定式也是不可满足的，进而说明原公式是永真的</p> </li> </ul> <h4 id=skolem>消去存在量词（<span>Skolem<span class=heti-spacing> </span></span>化<heti-adjacent class=heti-adjacent-half>）</heti-adjacent>：<a class=headerlink href=#skolem title="anchor link to this section for reference">¶</a></h4> <ul> <li>若该存在量词不在任何全称量词的辖域内，则用一个<strong>常量符号</strong>代替该存在量词辖域内的相应约束变元，这个常量叫<span class=heti-skip><span class=heti-spacing> </span>Skolem<span class=heti-spacing> </span></span>常量。</li> </ul> <p>若该存在量词在全称量词的辖域内，则用这些全称量词指导变元的一个函数代替该存在量词辖域内的相应约束变元，这样的函数称为<strong><span>Skolem<span class=heti-spacing> </span></span>函数</strong>。</p> <p><strong><span>Skolem<span class=heti-spacing> </span></span>标准型</strong>：在求子句集的过程中，消去存在量词之后，把所有全称量词都依次移到式子的最左边，再将右部的式子化为合取范式。</p> <p><img alt=image-20230214130658786 src=https://zyysite.oss-cn-hangzhou.aliyuncs.com/202412210957383.png></p> <h2 id=_46>机器学习<a class=headerlink href=#_46 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h2> <h3 id=_47>绪论<a class=headerlink href=#_47 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <p><strong>定义</strong>：计算机程序如何随着经验积累自动提高性能，系统自我改进的过程<span class=heti-skip><span class=heti-spacing> </span>;<span class=heti-spacing> </span></span>或计算机利用经验改善系统自身性能的行为</p> <p>简而言之，就是通过不断地向机器喂入数据来提高机器学习算法的性能</p> <p>学科交叉：</p> <ul> <li>同时机器学习也是一个多学科交叉的产物，它吸取了人工智能、概率统计、神经生物学、认知科学、信息论、控制论、计算复杂性理论、哲学等学科的成果。</li> <li>机器学习在很多应用领域发挥了重要的实用价值，特别是在数据挖掘、语音识别、图像处理、机器人、车辆自动驾驶、生物信息学、信息安全、遥感信息处理、计算金融学、工业过程控制。</li> </ul> <h3 id=_48>概念学习<a class=headerlink href=#_48 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <h2 id=mo><span>mo<span class=heti-spacing> </span></span>平台作业<a class=headerlink href=#mo title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h2> <h3 id=lab1>LAB1——双相障碍检测<a class=headerlink href=#lab1 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <p><a href=../class_source/renji/%E5%8F%8C%E7%9B%B8%E9%9A%9C%E7%A2%8D%E6%A3%80%E6%B5%8B/ >第一次实验报告</a><br></p> <h3 id=lab2>LAB2——机器人自动走迷宫<a class=headerlink href=#lab2 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <p><a href=../class_source/renji/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%87%AA%E5%8A%A8%E8%B5%B0%E8%BF%B7%E5%AE%AB/ >第二次实验报告</a><br></p> <h3 id=lab3>LAB3——口罩检测<a class=headerlink href=#lab3 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <p><a href=../class_source/renji/%E5%8F%A3%E7%BD%A9%E4%BD%A9%E6%88%B4%E6%A3%80%E6%B5%8B/ >第三次实验报告</a><br></p> <h3 id=lab4>LAB4——作家风格识别<a class=headerlink href=#lab4 title="anchor link to this section for reference"><span><span class=heti-spacing> </span>¶</span></a></h3> <p><a href=../class_source/renji/%E4%BD%9C%E5%AE%B6%E9%A3%8E%E6%A0%BC%E8%AF%86%E5%88%AB/ >第四次实验报告</a><br></p> <aside class=md-source-file> <span class=md-source-file__fact> <span class=md-icon title=最后更新> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"></path></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime">2024年12月22日 21:43:16</span> </span> <span class=md-source-file__fact> <span class=md-icon title=创建日期> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"></path></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime">2024年9月26日 02:44:14</span> </span> </aside> </article> </div> <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button class="md-top md-icon" data-md-component=top hidden type=button> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"></path></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <nav aria-label=页脚 class="md-footer__inner md-grid"> <a aria-label="上一页: 现代控制原理" href=../%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/ class="md-footer__link md-footer__link--prev"> <div class="md-footer__button md-icon"> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> 上一页 </span> <div class=md-ellipsis> 现代控制原理 </div> </div> </a> <a aria-label="下一页: 智能控制技术" href=../%E6%99%BA%E8%83%BD%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/ class="md-footer__link md-footer__link--next"> <div class=md-footer__title> <span class=md-footer__direction> 下一页 </span> <div class=md-ellipsis> 智能控制技术 </div> </div> <div class="md-footer__button md-icon"> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"></path></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright <span style=font-family:Arial;>©</span> 2023-2024 <a href=https://github.com/awslasasd target=_blank>awslasasd</a> </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ rel=noopener target=_blank> Material for MkDocs </a> </div> <div class=md-social> <a class=md-social__link href=https://github.com/awslasasd rel=noopener target=_blank title="awslasasd's Profile"> <svg viewbox="0 0 496 512" xmlns=http://www.w3.org/2000/svg><!-- Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tracking", "navigation.tabs", "navigation.path", "navigation.indexes", "navigation.top", "navigation.footer", "navigation.instant", "search.highlight", "search.share", "search.suggest", "toc.follow", "content.code.annotate", "content.code.copy", "content.tabs.link", "announce.dismiss"], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script> <script src=../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src=../../style/js/toc.js></script> <script src=../../style/js/mathjax.js></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script> </body> </html>